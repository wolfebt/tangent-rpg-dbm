<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TTRPG Hex Map Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Styles */
        body {
            font-family: 'Trebuchet MS', sans-serif;
            overflow: hidden;
            background-color: #1f2937; /* bg-gray-800 */
            color: #d1d5db; /* text-gray-300 */
            display: flex;
        }

        #main-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Top Right Controls */
        #topRightControls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 20;
            background-color: rgba(17, 24, 39, 0.8); /* bg-gray-900 with opacity */
            backdrop-filter: blur(4px);
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #374151;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        #topRightControls input {
            background-color: transparent;
            border: none;
            border-bottom: 2px solid #4b5563; /* border-gray-600 */
            padding: 0.25rem 0.1rem;
            color: #f9fafb; /* text-gray-50 */
            transition: border-color 0.2s;
        }
        #topRightControls input:focus {
            outline: none;
            border-bottom-color: #3b82f6; /* border-blue-500 */
        }
        #topRightControls label {
            font-size: 0.75rem;
            color: #9ca3af; /* text-gray-400 */
            margin-bottom: 0.1rem;
            display: block;
        }


        /* Canvas Styles */
        #canvas-container {
            flex-grow: 1;
            position: relative;
            height: 100%;
        }
        #mapCanvas, #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #drawingCanvas {
            z-index: 1;
            pointer-events: none; /* Pass clicks through by default */
        }
        #mapCanvas {
            cursor: crosshair;
            background-color: #374151; /* bg-gray-700 */
        }
        #mapCanvas.panning {
            cursor: grab;
        }
        #mapCanvas.pencil {
            cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 20h9'/><path d='M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z'/></svg>") 0 24, auto;
        }

        /* Control Panel Styles */
        #panelWrapper {
            width: 20rem; /* 320px */
            height: 100vh;
            display: flex;
            transition: width 0.3s ease-in-out;
            flex-shrink: 0;
            overflow: hidden;
        }
        #panelWrapper.closed {
            width: 0;
        }

        .control-container {
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
            width: 100%;
            height: 100%;
            flex-shrink: 0;
        }

        .control-panel {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            padding: 1rem;
            border-radius: 0.5rem;
        }
        .control-panel h3 {
            font-weight: 700;
            margin-bottom: 0;
            color: #f9fafb; /* text-gray-50 */
        }
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151;
            padding-bottom: 0.5rem;
            transition: background-color 0.2s;
        }
        .collapsible-header.active {
            background-color: #3b82f6;
        }
        .collapsible-header svg {
            transition: transform 0.3s;
        }
        .collapsible-header.collapsed svg {
            transform: rotate(-90deg);
        }
        .collapsible-content {
            padding-top: 0.75rem;
        }
        .collapsible-content.hidden {
            display: none;
        }

        .control-panel label {
            font-weight: 500;
            margin-bottom: 0.25rem;
            display: block;
        }
        .control-panel input[type="range"] {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px; background: #4b5563; border-radius: 5px;
            outline: none; opacity: 0.7; transition: opacity .2s;
        }
        .control-panel input[type="range"]:hover { opacity: 1; }
        .control-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: #3b82f6; cursor: pointer; border-radius: 50%;
        }
        .control-panel input[type="range"]::-moz-range-thumb {
            width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%;
        }

        .control-panel select, .control-panel button, .control-panel input[type="number"],
        .control-panel input[type="text"], .control-panel textarea, .control-panel input[type="color"] {
            width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #4b5563;
            background-color: #374151; color: #f9fafb; margin-bottom: 0.75rem; transition: all 0.2s;
        }
        .control-panel textarea { min-height: 80px; }
        .control-panel input[type="color"] { padding: 0.25rem; }
        .control-panel button {
            display: flex; align-items: center; justify-content: center;
        }
        .control-panel button:hover { background-color: #4b5563; }
        .control-panel.active {
            background-color: #1e40af; border-color: #3b82f6;
        }
        .control-panel button.active { background-color: #3b82f6; }
        .control-panel button:disabled {
            background-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* File Menu Styles */
        .file-dropdown {
            position: absolute; background-color: #1f2937; border: 1px solid #374151;
            border-radius: 0.375rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 50; width: 200px;
        }
        .file-dropdown-item {
            padding: 0.75rem 1rem; cursor: pointer; display: block; width: 100%; text-align: left;
        }
        .file-dropdown-item:hover { background-color: #374151; }

        /* Swatch & Layer Styles */
        .item-container, .layer-item {
            display: flex; flex-direction: row; align-items: center; padding: 0.5rem;
            border-radius: 0.375rem; border: 2px solid transparent; cursor: pointer; transition: all 0.2s;
        }
        .item-container.active, .layer-item.active {
            border-color: #3b82f6; background-color: #374151;
        }
        .item-container:hover, .layer-item:hover { background-color: #374151; }
        .texture-swatch, .object-swatch {
            width: 32px; height: 32px; border-radius: 0.375rem;
            border: 1px solid #4b5563; flex-shrink: 0;
        }
        .object-swatch {
            display: flex; align-items: center; justify-content: center; font-size: 24px;
        }
        .item-label, .layer-label {
            margin-left: 0.75rem; font-size: 14px; text-align: left; flex-grow: 1;
        }
        .layer-controls { display: flex; gap: 0.25rem; }
        .layer-controls button {
            padding: 0.25rem; background: none; border: none; color: #9ca3af;
        }
        .layer-controls button:hover { color: #f9fafb; background: #4b5563; }

        /* Collapsed Panel Bar */
        .collapsed-bar {
            position: absolute;
            top: 1rem;
            left: 0;
            z-index: 5;
            writing-mode: vertical-lr;
            background-color: #111827;
            color: #d1d5db;
            padding: 1rem 0.5rem;
            cursor: pointer;
            border-radius: 0 0.5rem 0.5rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            letter-spacing: 2px;
            font-weight: bold;
            flex-shrink: 0;
            transition: all 0.3s ease-in-out;
            height: 200px;
            pointer-events: auto;
        }
        .collapsed-bar.hidden {
            display: none;
        }

        /* Map Key Styles */
        #mapKeyWindow {
            position: absolute;
            top: 5rem;
            left: 22rem; /* Position next to the panel */
            width: 150px; /* NARROWER width */
            background-color: transparent; /* TRANSPARENT background */
            border: 1px solid transparent;
            border-radius: 0.5rem;
            z-index: 30;
            color: #d1d5db;
            display: flex;
            flex-direction: column;
        }
        #mapKeyHeader {
            padding: 0.25rem 0.5rem; /* Reduced padding */
            cursor: move;
            background-color: rgba(31, 41, 55, 0.9);
            border-bottom: 1px solid #374151;
            border-radius: 0.5rem 0.5rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        #mapKeyHeader h4 {
            font-weight: bold;
            font-size: 0.875rem; /* Smaller header font */
        }
        #mapKeyCloseBtn {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.1rem; /* Smaller close button */
            line-height: 1;
            padding: 0.1rem;
        }
        #mapKeyCloseBtn:hover {
            color: #f9fafb;
        }
        #mapKeyContent {
            padding: 0.5rem; /* Reduced padding */
            max-height: 350px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr; /* Single column layout */
            gap: 0.25rem; /* space between items */
        }
        .key-section-title {
            font-weight: 600;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 0.25rem;
            margin-top: 0.25rem;
            margin-bottom: 0.25rem;
            font-size: 0.8rem; /* Smaller section title */
            grid-column: 1 / -1; /* Span full width */
        }
        .key-item {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* Reduced gap */
            font-size: 0.75rem; /* Smaller font */
            background-color: rgba(17, 24, 39, 0.7); /* Background for readability */
            padding: 0.25rem;
            border-radius: 0.25rem;
        }
        .key-swatch {
            width: 20px; /* Reduced size */
            height: 20px; /* Reduced size */
            border-radius: 0.25rem;
            border: 1px solid #4b5563;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px; /* Reduced size */
        }
        .hidden {
            display: none !important;
        }

        /* Asset Manager Modal Styles */
        .asset-type-tab {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            text-align: left;
            transition: background-color 0.2s;
        }
        .asset-type-tab:hover {
            background-color: #374151;
        }
        .asset-type-tab.active {
            background-color: #3b82f6;
        }
    </style>
</head>
<body>
    <svg width="0" height="0" style="position:absolute;z-index:-1;">
        <defs>
            <pattern id="pattern-water" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#4c92c8"/><path d="M-5,5 Q-2.5,0 0,5 T5,5 T10,5 T15,5" stroke="#2b5a7a" stroke-width="1" fill="none"/></pattern>
            <pattern id="pattern-sand" width="6" height="6" patternUnits="userSpaceOnUse"><rect width="6" height="6" fill="#f0d9a0"/><circle cx="1" cy="1" r="1" fill="#b59a72"/><circle cx="4" cy="4" r="1" fill="#b59a72"/></pattern>
            <pattern id="pattern-grass" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#86c440"/><path d="M0,10 L5,0 L10,10" stroke="#4d7225" stroke-width="1" fill="none"/></pattern>
            <pattern id="pattern-plains" width="12" height="12" patternUnits="userSpaceOnUse"><rect width="12" height="12" fill="#a6d15a"/><path d="M0 6 H12 M6 0 V12" stroke="#6d8e35" stroke-width="0.5"/></pattern>
            <pattern id="pattern-forest" width="12" height="12" patternUnits="userSpaceOnUse"><rect width="12" height="12" fill="#4a8232"/><path d="M2 10 L6 2 L10 10 Z" fill="#2a4d1c"/></pattern>
            <pattern id="pattern-hills" width="15" height="15" patternUnits="userSpaceOnUse"><rect width="15" height="15" fill="#a08b6b"/><path d="M0 15 C 5 0, 10 0, 15 15" stroke="#6b5a46" stroke-width="2" fill="none"/></pattern>
            <pattern id="pattern-mountain" width="16" height="16" patternUnits="userSpaceOnUse"><rect width="16" height="16" fill="#6f6f6f"/><path d="M0 16 L8 0 L16 16 Z" stroke="#404040" stroke-width="1" fill="#707070"/></pattern>
            <pattern id="pattern-snow" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#ffffff"/><path d="M0 5 H10 M5 0 V10 M2 2 L8 8 M2 8 L8 2" stroke="#c0c0c0" stroke-width="1"/></pattern>
            <pattern id="pattern-dirt" width="8" height="8" patternUnits="userSpaceOnUse"><rect width="8" height="8" fill="#a07040"/><path d="M0 0 L8 8 M8 0 L0 8" stroke="#6b4a25" stroke-width="0.5"/></pattern>
            <pattern id="pattern-road" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#b0a89f"/><rect x="3" y="0" width="4" height="10" fill="#888279"/></pattern>
            <pattern id="pattern-lava" width="12" height="12" patternUnits="userSpaceOnUse"><rect width="12" height="12" fill="#e25822"/><circle cx="6" cy="6" r="5" fill="#e06030" opacity="0.5"/><circle cx="3" cy="9" r="3" fill="#cc3700" opacity="0.6"/></pattern>
            <pattern id="pattern-crags" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#5a5a5a"/><path d="M0 10 L5 0 L10 10" stroke="#303030" stroke-width="1.5" fill="none"/><path d="M0 5 L10 5" stroke="#303030" stroke-width="1" fill="none"/></pattern>
            <pattern id="pattern-swamp" width="12" height="12" patternUnits="userSpaceOnUse"><rect width="12" height="12" fill="#4d6642"/><path d="M-2,6 Q1,3 4,6 T10,6" stroke="#2c3e23" stroke-width="1.5" fill="none"/><circle cx="9" cy="3" r="1" fill="#526d1a"/></pattern>
            <pattern id="pattern-tundra" width="10" height="10" patternUnits="userSpaceOnUse"><rect width="10" height="10" fill="#cdd3d6"/><path d="M0 0 L10 10 M10 0 L0 10" stroke="#90989a" stroke-width="0.5"/></pattern>
        </defs>
    </svg>
    <div id="main-container">
        <div id="panelWrapper">
            <div id="controlContainer" class="control-container p-4 flex flex-col shadow-lg">
                <div class="flex justify-between items-center mb-4 flex-shrink-0 relative">
                    <div class="flex items-center">
                        <h2 class="text-2xl font-bold text-gray-100">Map Controls</h2>
                        <button id="userGuideBtn" class="ml-2 p-1 rounded-md hover:bg-gray-700" title="Open User Guide">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>
                        </button>
                        <!-- MAP KEY BUTTON -->
                        <button id="mapKeyBtn" class="ml-2 p-1 rounded-md hover:bg-gray-700" title="Toggle Map Key">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 18v3c0 .6.4 1 1 1h4v-3h3v-3h2l1.4-1.4a6.5 6.5 0 1 0-4-4Z"/><circle cx="16.5" cy="7.5" r=".5"/></svg>
                        </button>
                    </div>
                    <div class="flex items-center">
                        <button id="fileMenuBtn" class="p-2 rounded-md hover:bg-gray-700">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>
                        </button>
                        <button id="collapseBtn" class="p-2 rounded-md hover:bg-gray-700 ml-2" title="Hide Panel">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        </button>
                    </div>
                    <div id="fileDropdownMenu" class="file-dropdown hidden mt-2 right-0 top-full">
                        <button id="savePngBtn" class="file-dropdown-item">Save as PNG</button>
                        <button id="saveJsonBtn" class="file-dropdown-item">Save Map (.json)</button>
                        <button id="loadJsonBtn" class="file-dropdown-item">Load Map (.json)</button>
                    </div>
                    <input type="file" id="loadJsonInput" class="hidden" accept=".json">
                </div>
                
                <div class="flex-grow overflow-y-auto pr-2">
                    <div class="control-panel mb-4">
                        <h3 class="!border-b-0 !pb-2">Tools</h3>
                        <div class="grid grid-cols-3 gap-2">
                            <button id="toolTerrainBtn" class="active">Terrain</button>
                            <button id="toolPencilBtn">Pencil</button>
                            <button id="toolInspectorBtn">Inspector</button>
                        </div>
                    </div>

                    <div id="terrainOptionsPanel" class="control-panel mb-4">
                        <label for="terrainBrushMode">Terrain Brush</label>
                        <select id="terrainBrushMode">
                            <option value="hex">Hex</option>
                            <option value="spray">Spray</option>
                            <option value="line">Line</option>
                            <option value="rectangle">Rectangle</option>
                            <option value="ellipse">Ellipse</option>
                        </select>
                        <label for="brushSize">Brush/Object Size: <span id="brushSizeValue">1</span></label>
                        <input type="range" id="brushSize" min="1" max="10" value="1" class="mb-3">
                    </div>

                    <div id="pencilOptionsPanel" class="control-panel mb-4 hidden">
                        <label for="pencilBrushMode">Pencil Mode</label>
                        <select id="pencilBrushMode">
                            <option value="freestyle">Freestyle</option>
                            <option value="line">Line</option>
                            <option value="rectangle">Rectangle</option>
                            <option value="ellipse">Ellipse</option>
                        </select>
                        <div class="grid grid-cols-2 gap-4 mt-4">
                            <div>
                                <label for="pencilColorPicker">Color</label>
                                <input type="color" id="pencilColorPicker" value="#FFFFFF" class="!mb-0">
                            </div>
                            <div>
                                <label for="pencilWidth">Width: <span id="pencilWidthValue">5</span></label>
                                <input type="range" id="pencilWidth" min="1" max="50" value="5" class="!mb-0">
                            </div>
                        </div>
                    </div>

                    <div class="control-panel mb-4">
                        <div id="actionsHeader" class="collapsible-header">
                            <h3>Actions</h3>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </div>
                        <div id="actionsContent" class="collapsible-content">
                            <button id="addNewMapBtn" class="w-full mb-2 text-sm py-2">Add New Map</button>
                            <button id="createNewAssetBtn" class="w-full mb-2 text-sm py-2">Create New Asset</button>
                            <div class="grid grid-cols-4 gap-2 my-2">
                                <button id="zoomInBtn" title="Zoom In" class="text-2xl">+</button>
                                <button id="zoomOutBtn" title="Zoom Out" class="text-2xl">-</button>
                                <button id="undoBtn" title="Undo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10v4c0 .55.45 1 1 1h3l7 7V3L7 10H4c-.55 0-1 .45-1 1Z"/></svg>
                                </button>
                                <button id="redoBtn" title="Redo" disabled>
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5 6 3 1 5"/><path d="m3 10 3-2 5 2.5V18l-5-2.5-3 2v-8Z"/><path d="M22 10v4c0 .55-.45 1-1 1h-3l-7 7V3l7 7h3c.55 0 1 .45 1 1Z"/></svg>
                                </button>
                                <button id="eraserBtn" title="Eraser">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2='12' y2='15'></line><line x1='12' y1='9' x2='18' y2='15'></line></svg>
                                </button>
                                <button id="resetViewBtn" title="Reset View & Zoom">Center</button>
                            </div>
                        </div>
                    </div>
                                    
                    <div class="control-panel mb-4">
                        <div id="terrainHeader" class="collapsible-header collapsed">
                            <h3>Terrain Type</h3>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </div>
                        <div id="terrainContent" class="collapsible-content hidden">
                            <div id="terrainSelector" class="flex flex-col gap-2"></div>
                            <div class="mt-4 pt-4 border-t border-gray-700">
                                <h4 class="font-semibold mb-2">Custom Terrain</h4>
                                <input type="text" id="customTerrainName" placeholder="Terrain Name" class="mb-2">
                                <input type="color" id="customTerrainColor" value="#808080" class="mb-2">
                                <button id="addCustomTerrainBtn">Add Terrain</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-panel mb-4">
                        <div id="objectHeader" class="collapsible-header collapsed">
                            <h3>Objects</h3>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </div>
                        <div id="objectContent" class="collapsible-content hidden">
                            <div id="objectSelector" class="flex flex-col gap-2"></div>
                            <div class="mt-4 pt-4 border-t border-gray-700">
                                <h4 class="font-semibold mb-2">Custom Object</h4>
                                <input type="text" id="customObjectName" placeholder="Object Name" class="mb-2">
                                <input type="text" id="customObjectSymbol" placeholder="Symbol/Emoji" class="mb-2">
                                <button id="addCustomObjectBtn">Add Object</button>
                            </div>
                        </div>
                    </div>

                    <div id="textToolPanel" class="control-panel mb-4">
                        <div id="textHeader" class="collapsible-header collapsed">
                            <h3>Text</h3>
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                        </div>
                        <div id="textContent" class="collapsible-content hidden">
                            <label for="textInput">Text</label>
                            <input type="text" id="textInput" value="Label">
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="fontSizeInput">Size</label>
                                    <input type="number" id="fontSizeInput" value="20" min="1">
                                </div>
                                <div>
                                    <label for="fontColorInput">Color</label>
                                    <input type="color" id="fontColorInput" value="#FFFFFF">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="graphicsDropdown" class="mt-4">
                        <button id="graphicsBtn" class="w-full !mb-0 flex justify-between items-center bg-gray-800 p-3 rounded-md">
                            <span>Graphics Options</span>
                            <svg id="graphicsChevron" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="transition-transform"><polyline points="18 15 12 9 6 15"></polyline></svg>
                        </button>
                        <div id="graphicsContent" class="p-4 bg-gray-800 border border-gray-700 rounded-md mt-2 hidden">
                            <div class="control-panel mb-4">
                                <h3 class="!border-b-0 !pb-2 text-base font-semibold">Layers</h3>
                                <div id="layerContent" class="collapsible-content">
                                    <div id="layerList" class="flex flex-col gap-2 mb-4"></div>
                                    <div class="grid grid-cols-2 gap-2">
                                        <button id="addLayerBtn">Add Layer</button>
                                        <button id="deleteLayerBtn">Delete Layer</button>
                                    </div>
                                </div>
                            </div>

                            <div class="control-panel mb-4">
                                <h3 class="!border-b-0 !pb-2 text-base font-semibold">Grid Options</h3>
                                <div class="grid grid-cols-2 gap-4 items-center">
                                    <div>
                                        <label for="gridColorPicker" class="text-sm">Color</label>
                                        <input type="color" id="gridColorPicker" value="#111827" class="!p-1 !h-9 !mb-0">
                                    </div>
                                    <div class="flex items-center justify-end pt-5">
                                        <input type="checkbox" id="gridVisibleCheckbox" class="h-4 w-4 rounded !mb-0" checked>
                                        <label for="gridVisibleCheckbox" class="ml-2 !mb-0">Visible</label>
                                    </div>
                                </div>
                            </div>

                            <div class="control-panel">
                                <h3 class="!border-b-0 !pb-2 text-base font-semibold">Map Generation</h3>
                                <div id="mapGenerationContent" class="collapsible-content">
                                    <div class="mb-4">
                                        <div id="dimensionInputs">
                                            <div class="grid grid-cols-2 gap-2">
                                                <div>
                                                    <label for="mapWidth">Width</label>
                                                    <input type="number" id="mapWidth" value="50" min="1">
                                                </div>
                                                <div>
                                                    <label for="mapHeight">Height</label>
                                                    <input type="number" id="mapHeight" value="50" min="1">
                                                </div>
                                            </div>
                                        </div>
                                        <button id="generateBaseMapBtn" class="mt-2">Generate Blank Map</button>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="mapCanvas"></canvas>
            <canvas id="drawingCanvas"></canvas>
        </div>
        <div id="collapsedBar" class="collapsed-bar hidden">MAP CONTROLS</div>
        <div id="topRightControls">
            <div>
                <label for="mapNameInput">Map Name</label>
                <input type="text" id="mapNameInput" placeholder="Untitled Map" class="text-lg w-48">
            </div>
        </div>
    </div>

    <!-- MAP KEY WINDOW -->
    <div id="mapKeyWindow" class="hidden">
        <div id="mapKeyHeader">
            <h4>Map Key</h4>
            <button id="mapKeyCloseBtn">&times;</button>
        </div>
        <div id="mapKeyContent">
            <!-- Content will be dynamically generated here -->
        </div>
    </div>

    <script type="module">
        document.addEventListener('DOMContentLoaded', () => {
            // --- UI Elements ---
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const drawingCanvas = document.getElementById('drawingCanvas');
            const drawingCtx = drawingCanvas.getContext('2d');
            const mapNameInput = document.getElementById('mapNameInput');
            const brushSizeSlider = document.getElementById('brushSize');
            const brushSizeValue = document.getElementById('brushSizeValue');
            const terrainSelector = document.getElementById('terrainSelector');
            const objectSelector = document.getElementById('objectSelector');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const resetViewBtn = document.getElementById('resetViewBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            const gridColorPicker = document.getElementById('gridColorPicker');
            const gridVisibleCheckbox = document.getElementById('gridVisibleCheckbox');
            const mapWidthInput = document.getElementById('mapWidth');
            const mapHeightInput = document.getElementById('mapHeight');
            const generateBaseMapBtn = document.getElementById('generateBaseMapBtn');
            const layerList = document.getElementById('layerList');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const deleteLayerBtn = document.getElementById('deleteLayerBtn');
            const textToolPanel = document.getElementById('textToolPanel');
            const textHeader = document.getElementById('textHeader');
            const textInput = document.getElementById('textInput');
            const fontSizeInput = document.getElementById('fontSizeInput');
            const fontColorInput = document.getElementById('fontColorInput');
            const fileMenuBtn = document.getElementById('fileMenuBtn');
            const fileDropdownMenu = document.getElementById('fileDropdownMenu');
            const savePngBtn = document.getElementById('savePngBtn');
            const saveJsonBtn = document.getElementById('saveJsonBtn');
            const loadJsonBtn = document.getElementById('loadJsonBtn');
            const loadJsonInput = document.getElementById('loadJsonInput');
            const toolTerrainBtn = document.getElementById('toolTerrainBtn');
            const toolPencilBtn = document.getElementById('toolPencilBtn');
            const terrainOptionsPanel = document.getElementById('terrainOptionsPanel');
            const pencilOptionsPanel = document.getElementById('pencilOptionsPanel');
            const terrainBrushModeSelect = document.getElementById('terrainBrushMode');
            const pencilBrushModeSelect = document.getElementById('pencilBrushMode');
            const pencilColorPicker = document.getElementById('pencilColorPicker');
            const pencilWidthSlider = document.getElementById('pencilWidth');
            const pencilWidthValue = document.getElementById('pencilWidthValue');
            const graphicsBtn = document.getElementById('graphicsBtn');
            const graphicsContent = document.getElementById('graphicsContent');
            const graphicsChevron = document.getElementById('graphicsChevron');
            const panelWrapper = document.getElementById('panelWrapper');
            const collapseBtn = document.getElementById('collapseBtn');
            const collapsedBar = document.getElementById('collapsedBar');
            const userGuideBtn = document.getElementById('userGuideBtn');
            const accordionHeaders = document.querySelectorAll('.collapsible-header');
            // Map Key UI
            const mapKeyBtn = document.getElementById('mapKeyBtn');
            const mapKeyWindow = document.getElementById('mapKeyWindow');
            const mapKeyHeader = document.getElementById('mapKeyHeader');
            const mapKeyContent = document.getElementById('mapKeyContent');
            const mapKeyCloseBtn = document.getElementById('mapKeyCloseBtn');
            const addNewMapBtn = document.getElementById('addNewMapBtn');
            const createNewAssetBtn = document.getElementById('createNewAssetBtn');

            // --- Configuration ---
            const baseHexSize = 30;

            // --- State ---
            let mapGrid = {};
            let mapName = 'Untitled Map';
            let layers = [];
            let activeLayerIndex = 0;
            let currentTool = 'terrain';
            let nextClickAction = null;
            let terrainBrushMode = 'hex';
            let pencilBrushMode = 'freestyle';
            let brushSize = 1;
            let selectedTerrain = 'grass';
            let selectedObjectKey = 'Fantasy.Outside.tree';
            let view = { zoom: 1, offsetX: 0, offsetY: 0 };
            let gridColor = '#111827';
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            let isDrawingShape = false;
            let shapeStartPoint = null;
            let previewCanvas = document.createElement('canvas');
            let previewCtx = previewCanvas.getContext('2d');
            let isPainting = false;
            let pencilColor = '#FFFFFF';
            let pencilWidth = 5;
            let isPenciling = false;
            let currentPencilPath = null;
            let pencilPaths = [];
            let freestyleTerrainPaths = [];
            let currentFreestyleTerrainPath = null;
            let undoStack = [];
            let redoStack = [];
            // Map Key State
            let isDraggingKey = false;
            let keyDragOffset = { x: 0, y: 0 };

            // --- Data Definitions ---
            const terrains = {
                water: { color: '#4c92c8', name: 'Water', pattern: 'pattern-water' },
                sand: { color: '#f0d9a0', name: 'Sand', pattern: 'pattern-sand' },
                grass: { color: '#86c440', name: 'Grass', pattern: 'pattern-grass' },
                plains: { color: '#a6d15a', name: 'Plains', pattern: 'pattern-plains' },
                forest: { color: '#4a8232', name: 'Forest', pattern: 'pattern-forest' },
                hills: { color: '#a08b6b', name: 'Hills', pattern: 'pattern-hills' },
                mountain: { color: '#6f6f6f', name: 'Mountain', pattern: 'pattern-mountain' },
                snow: { color: '#ffffff', name: 'Snow', pattern: 'pattern-snow' },
                dirt: { color: '#a07040', name: 'Dirt', pattern: 'pattern-dirt' },
                road: { color: '#b0a89f', name: 'Road', pattern: 'pattern-road' },
                lava: { color: '#e25822', name: 'Lava', pattern: 'pattern-lava' },
                crags: { color: '#5a5a5a', name: 'Crags', pattern: 'pattern-crags' },
                swamp: { color: '#4d6642', name: 'Swamp', pattern: 'pattern-swamp' },
                tundra: { color: '#cdd3d6', name: 'Tundra', pattern: 'pattern-tundra' },
            };

            const objectCategories = {
                "Fantasy": {
                    "Outside": { tree: { symbol: 'üå≥', name: 'Tree' }, rock: { symbol: 'ü™®', name: 'Rock' }, stump: { symbol: 'ü™µ', name: 'Stump' }, flower: { symbol: 'üå∏', name: 'Flower' }, mushroom: { symbol: 'üçÑ', name: 'Mushroom' } },
                    "City": { house: { symbol: 'üè†', name: 'House' }, shop: { symbol: 'üè™', name: 'Shop' }, fountain: { symbol: '‚õ≤', name: 'Fountain' }, statue: { symbol: 'üóø', name: 'Statue' }, wall: { symbol: 'üß±', name: 'Wall' } },
                    "Castle/Fort": { tower: { symbol: 'üè∞', name: 'Tower'}, wall_stone: { symbol: 'üß±', name: 'Stone Wall' }, keep: { symbol: 'üèõÔ∏è', name: 'Keep' }, barracks: { symbol: 'üè¢', name: 'Barracks' } },
                    "Dungeon": { cave: {symbol: 'üï≥Ô∏è', name: 'Cave'}, monster: {symbol: 'üëπ', name: 'Monster'}, treasure: { symbol: 'üëë', name: 'Treasure' }, trap: { symbol: 'üï∏Ô∏è', name: 'Trap' }, stairs: { symbol: 'ü™ú', name: 'Stairs' }, door: { symbol: 'üö™', name: 'Door' } },
                    "Farm & Bar": { farmhouse: { symbol: 'üè°', name: 'Farmhouse'}, barn: { symbol: 'üõñ', name: 'Barn'}, well: { symbol: 'üï≥Ô∏è', name: 'Well' }, crops: { symbol: 'üåæ', name: 'Crops' }, inn: { symbol: 'üçª', name: 'Inn/Bar'} }
                },
                "Sci-Fi": {
                    "Outside": { alien_tree: { symbol: 'üå¥', name: 'Alien Flora' }, crystal: { symbol: 'üíé', name: 'Crystal' }, crater: { symbol: '‚òÑÔ∏è', name: 'Crater' }, rover: { symbol: 'üõ∞Ô∏è', name: 'Rover' } },
                    "Base/City": { habitat: { symbol: 'üõñ', name: 'Habitat Dome' }, lab: { symbol: 'üî¨', name: 'Lab' }, power_plant: { symbol: '‚ö°', name: 'Power Plant' }, comm_tower: { symbol: 'üóº', name: 'Comm Tower'}, landing_pad: { symbol: 'üöÄ', name: 'Landing Pad'} },
                    "Interior": { console: { symbol: 'üíª', name: 'Console' }, stasis_pod: { symbol: '‚ö∞Ô∏è', name: 'Stasis Pod'}, robot: { symbol: 'ü§ñ', name: 'Robot' }, alien: { symbol: 'üëΩ', name: 'Alien' }, airlock: { symbol: 'üö™', name: 'Airlock'} }
                },
                "Custom": {}
            };

            // --- Function Definitions ---

            function togglePanel(isCollapsing) {
                panelWrapper.classList.toggle('closed', isCollapsing);
                collapsedBar.classList.toggle('hidden', !isCollapsing);
                // Trigger a resize after the transition to redraw canvas correctly
                setTimeout(resizeCanvas, 300);
            }

            function resizeCanvas() {
                const container = document.getElementById('canvas-container');
                if (!container) return;
                const { width, height } = container.getBoundingClientRect();
                canvas.width = width;
                canvas.height = height;
                drawingCanvas.width = width;
                drawingCanvas.height = height;
                previewCanvas.width = width;
                previewCanvas.height = height;
                drawAll();
            }

            function generateBaseMap() {
                const width = mapWidthInput.value;
                const height = mapHeightInput.value;
                mapGrid = generateBaseMapGrid(width, height);

                layers = [
                    { name: 'Ground', visible: true, data: {} },
                    { name: 'Grid', visible: true, type: 'grid' },
                    { name: 'Objects', visible: true, data: {} }
                ];
                pencilPaths = [];
                freestyleTerrainPaths = [];
                undoStack = [];
                redoStack = [];
                activeLayerIndex = 0; // Default to ground layer
                renderLayers();
                updateUndoRedoButtons();
                updateMapKey();
                drawAll();
            }

            function generateBaseMapGrid(width, height) {
                const newGrid = {};
                const w = parseInt(width);
                const h = parseInt(height);

                for (let row = 0; row < h; row++) {
                    const r_offset = Math.floor(row / 2);
                    for (let col = -r_offset; col < w - r_offset; col++) {
                        newGrid[`${col},${row}`] = true;
                    }
                }
                return newGrid;
            }

            function centerView() {
                if (Object.keys(mapGrid).length === 0 || canvas.width === 0) return;

                const {mapPixelWidth, mapPixelHeight, mapCenterX, mapCenterY} = getMapPixelBounds();

                if(mapPixelWidth === 0 || mapPixelHeight === 0) return;

                view.zoom = Math.min(canvas.width / mapPixelWidth, canvas.height / mapPixelHeight) * 0.9;
                view.zoom = Math.max(0.1, Math.min(5, view.zoom));

                view.offsetX = (canvas.width / 2) - (mapCenterX * view.zoom);
                view.offsetY = (canvas.height / 2) - (mapCenterY * view.zoom);
                drawAll();
            }

            function drawAll() {
                requestAnimationFrame(() => {
                    ctx.clearRect(0,0, canvas.width, canvas.height);
                    drawingCtx.clearRect(0,0, drawingCanvas.width, drawingCanvas.height);
                    drawFrame(ctx);
                    drawFreestyleTerrainPaths();
                    drawPencilPaths();
                });
            }

            function drawGrid(targetCtx) {
                for (const key in mapGrid) {
                    const [q, r] = key.split(',').map(Number);
                    const { x, y } = hexToPixel(q, r);
                    drawHexOutline(targetCtx, x, y, gridColor);
                }
            }

            function drawFrame(targetCtx, bounds = null) {
                targetCtx.save();

                if (bounds) {
                    targetCtx.clearRect(0, 0, bounds.width, bounds.height);
                    targetCtx.translate(-bounds.minPxX, -bounds.minPxY);
                } else {
                    targetCtx.translate(view.offsetX, view.offsetY);
                    targetCtx.scale(view.zoom, view.zoom);
                }

                const topTerrains = getTopTerrains();

                for (const key in mapGrid) {
                    const [q, r] = key.split(',').map(Number);
                    const {x, y} = hexToPixel(q, r);
                    const terrainKey = topTerrains[key];
                    if (terrainKey) {
                        drawHex(targetCtx, x, y, terrains[terrainKey]);
                    }
                }

                layers.forEach(layer => {
                    if (!layer.visible) return;

                    if (layer.type === 'grid') {
                        drawGrid(targetCtx);
                        return;
                    }

                    for (const key in layer.data) {
                        const [q, r] = key.split(',').map(Number);
                        const { x, y } = hexToPixel(q, r);
                        const hexData = layer.data[key];

                        if (hexData.objectKey) {
                            const [mainCat, subCat, objKey] = hexData.objectKey.split('.');
                            if (objectCategories[mainCat] && objectCategories[mainCat][subCat] && objectCategories[mainCat][subCat][objKey]) {
                                const object = objectCategories[mainCat][subCat][objKey];
                                drawObject(targetCtx, x, y, object, hexData.size);
                            }
                        }
                        if (hexData.text) {
                            drawText(targetCtx, x, y, hexData.text, hexData.textSize, hexData.textColor);
                        }
                    }
                });

                targetCtx.restore();

                if(isDrawingShape && targetCtx === ctx) {
                    ctx.drawImage(previewCanvas, 0, 0);
                }
            }

            function drawHex(targetCtx, x, y, terrainOrColor) {
                targetCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const corner = getHexCorner({x, y}, baseHexSize, i);
                    targetCtx.lineTo(corner.x, corner.y);
                }
                targetCtx.closePath();

                if (typeof terrainOrColor === 'string') {
                    targetCtx.fillStyle = terrainOrColor;
                } else if (terrainOrColor && terrainOrColor.isCustom) {
                    targetCtx.fillStyle = terrainOrColor.color;
                } else if (terrainOrColor && terrainOrColor.canvasPattern) {
                    targetCtx.fillStyle = terrainOrColor.canvasPattern;
                } else if (terrainOrColor && terrainOrColor.color) {
                    targetCtx.fillStyle = terrainOrColor.color;
                }
                targetCtx.fill();
            }

            function drawHexOutline(targetCtx, x, y, strokeStyle) {
                targetCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const corner = getHexCorner({x, y}, baseHexSize, i);
                    targetCtx.lineTo(corner.x, corner.y);
                }
                targetCtx.closePath();
                targetCtx.strokeStyle = strokeStyle;
                targetCtx.lineWidth = 1.5 / (targetCtx === ctx ? view.zoom : 1);
                targetCtx.stroke();
            }

            function drawObject(targetCtx, x, y, object, size = 1) {
                if (object.isImage) {
                    const img = new Image();
                    img.src = object.src;
                    const imgSize = baseHexSize * 1.5 * size;
                    // Draw image centered on the hex
                    targetCtx.drawImage(img, x - imgSize / 2, y - imgSize / 2, imgSize, imgSize);
                } else {
                    targetCtx.font = `${baseHexSize * 1.2 * size}px Arial`;
                    targetCtx.textAlign = 'center';
                    targetCtx.textBaseline = 'middle';
                    targetCtx.fillText(object.symbol, x, y);
                }
            }

            function drawText(targetCtx, x, y, text, size, color) {
                targetCtx.font = `${size}px 'Trebuchet MS'`;
                targetCtx.fillStyle = color;
                targetCtx.textAlign = 'center';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText(text, x, y);
            }

            function drawFreestyleTerrainPaths() {
                drawingCtx.save();
                drawingCtx.translate(view.offsetX, view.offsetY);
                drawingCtx.scale(view.zoom, view.zoom);

                const allPaths = [...freestyleTerrainPaths];
                if(isPainting && currentFreestyleTerrainPath) {
                    allPaths.push(currentFreestyleTerrainPath);
                }

                allPaths.forEach(path => {
                    if (path.points.length < 1) return;
                    const terrain = terrains[path.terrain];
                    if (!terrain || !terrain.canvasPattern) return;

                    drawingCtx.strokeStyle = terrain.canvasPattern;
                    drawingCtx.lineWidth = path.width;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';

                    if (path.points.length < 2) {
                        drawingCtx.fillStyle = terrain.canvasPattern;
                        drawingCtx.beginPath();
                        drawingCtx.arc(path.points[0].x, path.points[0].y, path.width / 2, 0, 2 * Math.PI);
                        drawingCtx.fill();
                    } else {
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(path.points[0].x, path.points[0].y);
                        for(let i=1; i < path.points.length; i++) {
                            drawingCtx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        drawingCtx.stroke();
                    }
                });
                drawingCtx.restore();
            }

            function drawPencilPaths() {
                drawingCtx.save();
                drawingCtx.translate(view.offsetX, view.offsetY);
                drawingCtx.scale(view.zoom, view.zoom);

                const allPaths = [...pencilPaths];
                if(isPenciling && currentPencilPath) {
                    allPaths.push(currentPencilPath);
                }

                allPaths.forEach(path => {
                    if (path.type === 'freestyle') {
                        if (path.points.length < 2) return;
                        drawingCtx.beginPath();
                        drawingCtx.strokeStyle = path.color;
                        drawingCtx.lineWidth = path.width;
                        drawingCtx.lineCap = 'round';
                        drawingCtx.lineJoin = 'round';
                        drawingCtx.moveTo(path.points[0].x, path.points[0].y);
                        for(let i=1; i < path.points.length; i++) {
                            drawingCtx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        drawingCtx.stroke();
                    } else if (path.type === 'line') {
                        drawingCtx.beginPath();
                        drawingCtx.strokeStyle = path.color;
                        drawingCtx.lineWidth = path.width;
                        drawingCtx.moveTo(path.start.x, path.start.y);
                        drawingCtx.lineTo(path.end.x, path.end.y);
                        drawingCtx.stroke();
                    } else if (path.type === 'rectangle') {
                        drawingCtx.beginPath();
                        drawingCtx.strokeStyle = path.color;
                        drawingCtx.lineWidth = path.width;
                        drawingCtx.rect(path.start.x, path.start.y, path.end.x - path.start.x, path.end.y - path.start.y);
                        drawingCtx.stroke();
                    } else if (path.type === 'ellipse') {
                        drawingCtx.beginPath();
                        drawingCtx.strokeStyle = path.color;
                        drawingCtx.lineWidth = path.width;
                        const rx = Math.abs(path.end.x - path.start.x) / 2;
                        const ry = Math.abs(path.end.y - path.start.y) / 2;
                        const cx = path.start.x + (path.end.x - path.start.x) / 2;
                        const cy = path.start.y + (path.end.y - path.start.y) / 2;
                        drawingCtx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        drawingCtx.stroke();
                    }
                });
                drawingCtx.restore();
            }

            function getMapPixelBounds() {
                let minPxX = Infinity, maxPxX = -Infinity, minPxY = Infinity, maxPxY = -Infinity;
                const hexVisualWidth = baseHexSize * Math.sqrt(3);
                const hexVisualHeight = baseHexSize * 2;

                if (Object.keys(mapGrid).length === 0) {
                    return { minPxX: 0, maxPxX: 0, minPxY: 0, maxPxY: 0, mapPixelWidth: 0, mapPixelHeight: 0, mapCenterX: 0, mapCenterY: 0};
                }

                for (const key in mapGrid) {
                    const [q, r] = key.split(',').map(Number);
                    const { x, y } = hexToPixel(q, r);
                    minPxX = Math.min(minPxX, x - hexVisualWidth / 2);
                    maxPxX = Math.max(maxPxX, x + hexVisualWidth / 2);
                    minPxY = Math.min(minPxY, y - hexVisualHeight / 2);
                    maxPxY = Math.max(maxPxY, y + hexVisualHeight / 2);
                }

                const mapPixelWidth = maxPxX - minPxX;
                const mapPixelHeight = maxPxY - minPxY;
                const mapCenterX = minPxX + mapPixelWidth / 2;
                const mapCenterY = minPxY + mapPixelHeight / 2;
                return {minPxX, maxPxX, minPxY, maxPxY, mapPixelWidth, mapPixelHeight, mapCenterX, mapCenterY};
            }

            function hexToPixel(q, r) {
                const x = baseHexSize * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
                const y = baseHexSize * (3 / 2 * r);
                return { x, y };
            }

            function pixelToHex(x, y, isFreeform = false) {
                const worldX = (x - view.offsetX) / view.zoom;
                const worldY = (y - view.offsetY) / view.zoom;
                if(isFreeform) return { x: worldX, y: worldY };

                const q_frac = (Math.sqrt(3) / 3 * worldX - 1 / 3 * worldY) / baseHexSize;
                const r_frac = (2 / 3 * worldY) / baseHexSize;
                return axialRound(q_frac, r_frac);
            }

            function axialRound(q_frac, r_frac) {
                const s_frac = -q_frac - r_frac;
                let q = Math.round(q_frac);
                let r = Math.round(r_frac);
                let s = Math.round(s_frac);
                const q_diff = Math.abs(q - q_frac);
                const r_diff = Math.abs(r - r_frac);
                const s_diff = Math.abs(s - s_frac);
                if (q_diff > r_diff && q_diff > s_diff) {
                    q = -r - s;
                } else if (r_diff > s_diff) {
                    r = -q - s;
                }
                return { q, r };
            }

            function getHexCorner(center, size, i) {
                const angle_deg = 60 * i + 30; // Start angle at 30 degrees for pointy top
                const angle_rad = Math.PI / 180 * angle_deg;
                return {
                    x: center.x + size * Math.cos(angle_rad),
                    y: center.y + size * Math.sin(angle_rad)
                };
            }

            function getTopTerrains() {
                const topTerrains = {};
                for (let i = 0; i < layers.length; i++) { // Iterate from bottom to top
                    const layer = layers[i];
                    if (!layer.visible || layer.type === 'grid') continue;
                    for (const key in layer.data) {
                        if (layer.data[key].terrain) { // If terrain exists, it overwrites lower layers
                            topTerrains[key] = layer.data[key].terrain;
                        }
                    }
                }
                return topTerrains;
            }

            function saveState() {
                undoStack.push({
                    layers: JSON.parse(JSON.stringify(layers)),
                    pencilPaths: JSON.parse(JSON.stringify(pencilPaths)),
                    freestyleTerrainPaths: JSON.parse(JSON.stringify(freestyleTerrainPaths)),
                });
                redoStack = [];
                updateUndoRedoButtons();
            }

            function undo() {
                if (undoStack.length === 0) return;
                const currentState = {
                    layers: JSON.parse(JSON.stringify(layers)),
                    pencilPaths: JSON.parse(JSON.stringify(pencilPaths)),
                    freestyleTerrainPaths: JSON.parse(JSON.stringify(freestyleTerrainPaths)),
                };
                redoStack.push(currentState);

                const previousState = undoStack.pop();
                layers = previousState.layers;
                pencilPaths = previousState.pencilPaths;
                freestyleTerrainPaths = previousState.freestyleTerrainPaths;

                drawAll();
                renderLayers();
                updateUndoRedoButtons();
                updateMapKey();
            }

            function redo() {
                if (redoStack.length === 0) return;
                const currentState = {
                    layers: JSON.parse(JSON.stringify(layers)),
                    pencilPaths: JSON.parse(JSON.stringify(pencilPaths)),
                    freestyleTerrainPaths: JSON.parse(JSON.stringify(freestyleTerrainPaths)),
                };
                undoStack.push(currentState);

                const nextState = redoStack.pop();
                layers = nextState.layers;
                pencilPaths = nextState.pencilPaths;
                freestyleTerrainPaths = nextState.freestyleTerrainPaths;

                drawAll();
                renderLayers();
                updateUndoRedoButtons();
                updateMapKey();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }

            function applyTool(e, endHex, toolOverride = null) {
                if (!layers.length) return;
                const toolToUse = toolOverride || currentTool;

                const activeLayer = layers[activeLayerIndex];
                if (activeLayer.type === 'grid') {
                    showModal("Cannot draw on the Grid layer. Please select another layer.");
                    return;
                }
                const affectedHexes = getHexesForTool(e, endHex, toolToUse);

                affectedHexes.forEach(hex => {
                    const key = `${hex.q},${hex.r}`;
                    if (mapGrid[key]) {
                        if (!activeLayer.data[key]) activeLayer.data[key] = {};

                        if (toolToUse === 'terrain') {
                        activeLayer.data[key] = { ...activeLayer.data[key], terrain: selectedTerrain };
                        } else if (toolToUse === 'placeObject') {
                            activeLayer.data[key] = { ...activeLayer.data[key], objectKey: selectedObjectKey, size: brushSize };
                        } else if (toolToUse === 'placeText') {
                            activeLayer.data[key] = {
                                ...activeLayer.data[key],
                                text: textInput.value,
                                textSize: fontSizeInput.value,
                                textColor: fontColorInput.value
                            };
                        } else if (toolToUse === 'eraser') {
                        if(activeLayer.data[key]) {
                            delete activeLayer.data[key];
                        }
                        }
                    }
                });
                drawAll();
                updateMapKey();
            }

            function getHexesForTool(e, endHex, toolOverride = null) {
                const toolToUse = toolOverride || currentTool;
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const centerHex = endHex || pixelToHex(mouseX, mouseY);
                const startHex = shapeStartPoint ? shapeStartPoint : centerHex;

                if (toolToUse === 'terrain') {
                    switch(terrainBrushMode) {
                        case 'spray':
                        {
                            const results = [];
                            const allHexesInBrush = getHexesInBrush(centerHex);
                            const density = Math.min(1, 0.1 + (brushSize / 10));
                            const numToPick = Math.max(1, Math.floor(allHexesInBrush.length * density));

                            for (let i = 0; i < numToPick; i++) {
                                const randomIndex = Math.floor(Math.random() * allHexesInBrush.length);
                                results.push(allHexesInBrush[randomIndex]);
                                allHexesInBrush.splice(randomIndex, 1);
                            }
                            return results;
                        }
                        case 'hex':
                            return getHexesInBrush(centerHex);
                        case 'line':
                            return getHexesForLine(startHex, centerHex);
                        case 'rectangle':
                            return getHexesForRectangle(startHex, centerHex);
                        case 'ellipse':
                            return getHexesForEllipse(startHex, centerHex);
                    }
                } else if (toolToUse === 'placeObject' || toolToUse === 'placeText') {
                    return [centerHex];
                } else if (toolToUse === 'eraser') {
                    return getHexesInBrush(centerHex);
                }
                return [];
            }

            function getHexesInBrush(centerHex) {
                const results = [];
                const range = brushSize - 1;
                for (let q = -range; q <= range; q++) {
                    for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {
                        results.push({ q: centerHex.q + q, r: centerHex.r + r });
                    }
                }
                return results;
            }

            function cubeLerp(a, b, t) {
                return { q: a.q * (1 - t) + b.q * t, r: a.r * (1 - t) + b.r * t };
            }

            function getHexesForLine(start, end) {
                if(!start || !end) return [];
                const n = axialDistance(start, end);
                const results = [];
                for (let i = 0; i <= n; i++) {
                    const cubeCoords = cubeLerp(start, end, (1.0 / n) * i);
                    results.push(axialRound(cubeCoords.q, cubeCoords.r));
                }
                return results;
            }

            function getHexesForRectangle(start, end) {
                if(!start || !end) return [];
                const results = [];
                const q_min = Math.min(start.q, end.q);
                const q_max = Math.max(start.q, end.q);
                const r_min = Math.min(start.r, end.r);
                const r_max = Math.max(start.r, end.r);

                for (let q = q_min; q <= q_max; q++) {
                    for (let r = r_min; r <= r_max; r++) {
                        results.push({ q, r });
                    }
                }
                return results;
            }

            function getHexesForEllipse(start, end) {
                if(!start || !end) return [];
                const results = [];
                const centerQ = (start.q + end.q) / 2;
                const centerR = (start.r + end.r) / 2;
                const radiusQ = Math.abs(start.q - end.q) / 2;
                const radiusR = Math.abs(start.r - end.r) / 2;

                const q_min = Math.floor(centerQ - radiusQ);
                const q_max = Math.ceil(centerQ + radiusQ);
                const r_min = Math.floor(centerR - radiusR);
                const r_max = Math.ceil(centerR + radiusR);

                for (let q = q_min; q <= q_max; q++) {
                    for (let r = r_min; r <= r_max; r++) {
                        if (radiusQ === 0 || radiusR === 0) continue;
                        const dq = (q - centerQ) / radiusQ;
                        const dr = (r - centerR) / radiusR;
                        if( (dq * dq) + (dr * dr) <= 1) {
                            results.push({ q, r });
                        }
                    }
                }
                return results;
            }

            function axialDistance(hexA, hexB) {
                return (Math.abs(hexA.q - hexB.q) + Math.abs(hexA.q + hexA.r - hexB.q - hexB.r) + Math.abs(hexA.r - hexB.r)) / 2;
            }

            function renderLayers() {
                layerList.innerHTML = '';
                layers.forEach((layer, index) => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.classList.toggle('active', index === activeLayerIndex);
                    item.dataset.index = index;

                    const label = document.createElement('div');
                    label.className = 'layer-label';
                    label.textContent = layer.name;

                    const controls = document.createElement('div');
                    controls.className = 'layer-controls';

                    const visBtn = document.createElement('button');
                    visBtn.innerHTML = layer.visible
                        ? `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`
                        : `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>`;
                    visBtn.title = "Toggle Visibility";
                    visBtn.onclick = (e) => { e.stopPropagation(); toggleLayerVisibility(index); };

                    const upBtn = document.createElement('button');
                    upBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="18 15 12 9 6 15"></polyline></svg>`;
                    upBtn.title = "Move Up";
                    upBtn.onclick = (e) => { e.stopPropagation(); moveLayer(index, -1); };

                    const downBtn = document.createElement('button');
                    downBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>`;
                    downBtn.title = "Move Down";
                    downBtn.onclick = (e) => { e.stopPropagation(); moveLayer(index, 1); };

                    item.onclick = () => { activeLayerIndex = index; renderLayers(); };

                    controls.appendChild(visBtn);
                    controls.appendChild(upBtn);
                    controls.appendChild(downBtn);
                    item.appendChild(label);
                    item.appendChild(controls);
                    layerList.appendChild(item);
                });
            }

            function addNewLayer(name = 'New Layer') {
                saveState();
                const newName = name === 'New Layer' ? `${name} ${layers.length + 1}` : name;
                layers.push({ name: newName, visible: true, data: {} });
                activeLayerIndex = layers.length - 1;
                renderLayers();
            }

            function deleteActiveLayer() {
                const layer = layers[activeLayerIndex];
                if (layer.name === 'Ground' || layer.name === 'Grid') {
                    showModal("The Ground and Grid layers cannot be deleted.");
                    return;
                }
                if (layers.length <= 2) {
                    showModal("You cannot delete the last layer.");
                    return;
                }
                saveState();
                layers.splice(activeLayerIndex, 1);
                if (activeLayerIndex >= layers.length) {
                    activeLayerIndex = layers.length - 1;
                }
                renderLayers();
                drawAll();
                updateMapKey();
            }

            function moveLayer(index, direction) {
                if ((index === 0 && direction === -1) || (index === layers.length - 1 && direction === 1)) {
                    return;
                }
                saveState();
                const newIndex = index + direction;
                [layers[index], layers[newIndex]] = [layers[newIndex], layers[index]];
                activeLayerIndex = newIndex;
                renderLayers();
                drawAll();
            }

            function toggleLayerVisibility(index) {
                saveState();
                layers[index].visible = !layers[index].visible;
                renderLayers();
                drawAll();
                updateMapKey();
            }

            function getSafeFilename(name) {
                return name.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'untitled-map';
            }

            function saveAsPNGLogic() {
                const { mapPixelWidth, mapPixelHeight, minPxX, minPxY } = getMapPixelBounds();

                if (mapPixelWidth <= 0 || mapPixelHeight <= 0) {
                    showModal("Cannot save an empty map.");
                    return;
                }

                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = mapPixelWidth;
                offscreenCanvas.height = mapPixelHeight;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                offscreenCtx.fillStyle = '#374151'; // bg-gray-700
                offscreenCtx.fillRect(0, 0, mapPixelWidth, mapPixelHeight);

                const bounds = { width: mapPixelWidth, height: mapPixelHeight, minPxX, minPxY };

                drawFrame(offscreenCtx, bounds);

                offscreenCtx.save();
                offscreenCtx.translate(-minPxX, -minPxY);
                drawFreestyleTerrainPathsForExport(offscreenCtx);
                drawPencilPathsForExport(offscreenCtx);
                offscreenCtx.restore();

                if (!mapKeyWindow.classList.contains('hidden')) {
                    const keyRect = mapKeyWindow.getBoundingClientRect();
                    const canvasRect = canvas.getBoundingClientRect();
                    const keyCanvasX = keyRect.left - canvasRect.left;
                    const keyCanvasY = keyRect.top - canvasRect.top;
                    const keyWorldX = (keyCanvasX - view.offsetX) / view.zoom;
                    const keyWorldY = (keyCanvasY - view.offsetY) / view.zoom;
                    const keyDrawX = keyWorldX - minPxX;
                    const keyDrawY = keyWorldY - minPxY;
                    drawKeyOnContext(offscreenCtx, keyDrawX, keyDrawY);
                }

                const tagText = "TTRPG HEX MAP MAKER by Wolfe.BT@TangentLLC";
                offscreenCtx.font = "200 14px 'Trebuchet MS'";
                offscreenCtx.fillStyle = "rgba(0, 0, 0, 0.8)";
                offscreenCtx.textAlign = "left";
                offscreenCtx.fillText(tagText, 10, mapPixelHeight - 10);

                const dataUrl = offscreenCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `${getSafeFilename(mapName)}.png`;
                link.href = dataUrl;
                link.click();
            }

            function saveAsJSONLogic() {
                const mapData = {
                    name: mapName,
                    grid: mapGrid,
                    layers: layers,
                    pencilPaths: pencilPaths,
                    freestyleTerrainPaths: freestyleTerrainPaths,
                };
                const jsonString = JSON.stringify(mapData, null, 2);
                const blob = new Blob([jsonString], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `${getSafeFilename(mapName)}.json`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }

            function promptForMapNameAndSave(saveFunction) {
                if (mapName.trim() === '' || mapName.toLowerCase().includes('untitled')) {
                    showNamePromptModal(saveFunction);
                } else {
                    saveFunction();
                }
            }

            function drawFreestyleTerrainPathsForExport(targetCtx) {
                freestyleTerrainPaths.forEach(path => {
                    if (path.points.length < 1) return;
                    const terrain = terrains[path.terrain];
                    if (!terrain || !terrain.canvasPattern) return;

                    targetCtx.strokeStyle = terrain.canvasPattern;
                    targetCtx.lineWidth = path.width;
                    targetCtx.lineCap = 'round';
                    targetCtx.lineJoin = 'round';

                    if (path.points.length < 2) {
                        targetCtx.fillStyle = terrain.canvasPattern;
                        targetCtx.beginPath();
                        targetCtx.arc(path.points[0].x, path.points[0].y, path.width / 2, 0, 2 * Math.PI);
                        targetCtx.fill();
                    } else {
                        targetCtx.beginPath();
                        targetCtx.moveTo(path.points[0].x, path.points[0].y);
                        for(let i=1; i < path.points.length; i++) {
                            targetCtx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        targetCtx.stroke();
                    }
                });
            }

            function drawPencilPathsForExport(targetCtx) {
                pencilPaths.forEach(path => {
                    if (path.type === 'freestyle') {
                        if (path.points.length < 2) return;
                        targetCtx.beginPath();
                        targetCtx.strokeStyle = path.color;
                        targetCtx.lineWidth = path.width;
                        targetCtx.lineCap = 'round';
                        targetCtx.lineJoin = 'round';
                        targetCtx.moveTo(path.points[0].x, path.points[0].y);
                        for(let i=1; i < path.points.length; i++) {
                            targetCtx.lineTo(path.points[i].x, path.points[i].y);
                        }
                        targetCtx.stroke();
                    } else if (path.type === 'line') {
                        targetCtx.beginPath();
                        targetCtx.strokeStyle = path.color;
                        targetCtx.lineWidth = path.width;
                        targetCtx.moveTo(path.start.x, path.start.y);
                        targetCtx.lineTo(path.end.x, path.end.y);
                        targetCtx.stroke();
                    } else if (path.type === 'rectangle') {
                        targetCtx.beginPath();
                        targetCtx.strokeStyle = path.color;
                        targetCtx.lineWidth = path.width;
                        targetCtx.rect(path.start.x, path.start.y, path.end.x - path.start.x, path.end.y - path.start.y);
                        targetCtx.stroke();
                    } else if (path.type === 'ellipse') {
                        targetCtx.beginPath();
                        targetCtx.strokeStyle = path.color;
                        targetCtx.lineWidth = path.width;
                        const rx = Math.abs(path.end.x - path.start.x) / 2;
                        const ry = Math.abs(path.end.y - path.start.y) / 2;
                        const cx = path.start.x + (path.end.x - start.x) / 2;
                        const cy = path.start.y + (path.end.y - start.y) / 2;
                        targetCtx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        targetCtx.stroke();
                    }
                });
            }

            function loadFromJSON(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedData = JSON.parse(event.target.result);
                        if (loadedData && loadedData.grid && Array.isArray(loadedData.layers)) {
                            mapGrid = loadedData.grid;
                            layers = loadedData.layers;
                            pencilPaths = loadedData.pencilPaths || [];
                            freestyleTerrainPaths = loadedData.freestyleTerrainPaths || [];
                            mapName = loadedData.name || 'Untitled Loaded Map';
                            mapNameInput.value = mapName;
                            activeLayerIndex = 0;
                            undoStack = [];
                            redoStack = [];
                            updateUndoRedoButtons();
                            renderLayers();
                            centerView();
                            setTimeout(updateMapKey, 100);
                        } else {
                            throw new Error("Invalid map file format.");
                        }
                    } catch (err) {
                        showModal("Error: Could not load map. File may be corrupt or in the wrong format.");
                        console.error(err);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }

            async function initializePatterns(targetCtx) {
                const promises = Object.values(terrains).map(terrain => {
                    return new Promise((resolve, reject) => {
                        const patternEl = document.getElementById(terrain.pattern);
                        if (!patternEl) {
                            console.warn(`Pattern element not found: ${terrain.pattern}`);
                            return resolve();
                        }

                        const img = new Image();
                        img.onload = () => {
                            try {
                                terrain.canvasPattern = targetCtx.createPattern(img, 'repeat');
                                resolve();
                            } catch (e) {
                                console.error(`Error creating pattern for ${terrain.name}:`, e);
                                reject(e);
                            }
                        };
                        img.onerror = (err) => {
                            console.error(`Failed to load pattern image for ${terrain.name}`, err);
                            reject(err);
                        };
                        img.src = getPatternDataUri(terrain.pattern);
                    });
                });
                await Promise.all(promises);
            }

            function getPatternDataUri(patternId) {
                const pattern = document.getElementById(patternId);
                if (!pattern) return '';

                const width = pattern.getAttribute('width');
                const height = pattern.getAttribute('height');

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                defs.appendChild(pattern.cloneNode(true));
                svg.appendChild(defs);

                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', '100%');
                rect.setAttribute('height', '100%');
                rect.setAttribute('fill', `url(#${patternId})`);
                svg.appendChild(rect);

                const xml = new XMLSerializer().serializeToString(svg);
                return `data:image/svg+xml;base64,${btoa(xml)}`;
            }

            function populateSelectors() {
                terrainSelector.innerHTML = '';
                Object.keys(terrains).forEach(key => {
                    const terrain = terrains[key];
                    const itemContainer = document.createElement('div');
                    itemContainer.className = 'item-container';
                    itemContainer.dataset.terrain = key;
                    itemContainer.addEventListener('click', () => {
                        currentTool = 'terrain';
                        selectedTerrain = key;
                        nextClickAction = null;
                        updateActiveSwatches();
                    });

                    const swatch = document.createElement('div');
                    swatch.className = 'texture-swatch';
                    if (terrain.isCustom) {
                        swatch.style.backgroundColor = terrain.color;
                    } else {
                        swatch.style.backgroundImage = `url(${getPatternDataUri(terrain.pattern)})`;
                    }

                    const label = document.createElement('div');
                    label.className = 'item-label';
                    label.textContent = terrain.name;

                    itemContainer.appendChild(swatch);
                    itemContainer.appendChild(label);
                    terrainSelector.appendChild(itemContainer);
                });

                objectSelector.innerHTML = '';
                Object.keys(objectCategories).forEach(mainCatKey => {
                    const mainCat = objectCategories[mainCatKey];
                    Object.keys(mainCat).forEach(subCatKey => {
                        const subCat = mainCat[subCatKey];
                        Object.keys(subCat).forEach(objKey => {
                            const item = subCat[objKey];
                            const fullKey = `${mainCatKey}.${subCatKey}.${objKey}`;
                            const itemContainer = document.createElement('div');
                            itemContainer.className = 'item-container';
                            itemContainer.dataset.objectKey = fullKey;
                            itemContainer.addEventListener('click', () => {
                                nextClickAction = 'placeObject';
                                selectedObjectKey = fullKey;
                                updateActiveSwatches();
                            });

                            let swatchHTML;
                            if (item.isImage) {
                                swatchHTML = `<div class="object-swatch p-0.5"><img src="${item.src}" class="w-full h-full object-cover rounded-md"/></div>`;
                            } else {
                                swatchHTML = `<div class="object-swatch">${item.symbol}</div>`;
                            }

                            itemContainer.innerHTML = `
                                ${swatchHTML}
                                <div class="item-label">${item.name}</div>
                            `;
                            objectSelector.appendChild(itemContainer);
                        });
                    });
                });

                updateActiveSwatches();
            }

            function updateActiveSwatches() {
                document.querySelectorAll('.item-container.active, .control-panel button.active, .collapsible-header.active').forEach(el => el.classList.remove('active'));
                terrainOptionsPanel.classList.add('hidden');
                pencilOptionsPanel.classList.add('hidden');
                canvas.classList.remove('pencil');

                if (nextClickAction === 'placeObject') {
                    document.querySelector(`.item-container[data-object-key="${selectedObjectKey}"]`)?.classList.add('active');
                } else if (nextClickAction === 'placeText') {
                    textHeader.classList.add('active');
                } else if (currentTool === 'terrain') {
                    toolTerrainBtn.classList.add('active');
                    terrainOptionsPanel.classList.remove('hidden');
                    document.querySelector(`.item-container[data-terrain="${selectedTerrain}"]`)?.classList.add('active');
                } else if (currentTool === 'pencil') {
                    toolPencilBtn.classList.add('active');
                    pencilOptionsPanel.classList.remove('hidden');
                    canvas.classList.add('pencil');
                } else if (currentTool === 'eraser') {
                    eraserBtn.classList.add('active');
                } else if (currentTool === 'inspector') {
                    document.getElementById('toolInspectorBtn').classList.add('active');
                }
            }

            function showUserGuide() {
                const guideHTML = `
                    <div class="text-left text-sm text-gray-300 space-y-4">
                        <h3 class="text-xl font-bold text-white">Welcome to the TTRPG Hex Map Maker!</h3>
                        <p>This guide will walk you through all the features of the map maker, helping you create detailed and beautiful hex maps for your tabletop games.</p>

                        <h4 class="text-lg font-bold text-white border-t border-gray-600 pt-3 mt-4">1. The Interface at a Glance</h4>
                        <p>The screen is divided into three main areas:</p>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>Left:</strong> The <strong>Control Panel</strong> is where you'll find all your tools for drawing, painting, and managing your map.</li>
                            <li><strong>Center:</strong> The <strong>Canvas</strong> is your main workspace where you'll build your map.</li>
                            <li><strong>Top-Right:</strong> Here you can set your <strong>Map Name</strong>.</li>
                        </ul>

                        <h4 class="text-lg font-bold text-white border-t border-gray-600 pt-3 mt-4">2. The Control Panel: Your Creative Toolkit</h4>
                        <p>The control panel on the left contains everything you need to build your world.</p>

                        <h5 class="text-md font-semibold text-white">Main Tools</h5>
                        <p>At the very top, you have two primary tool modes:</p>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>Terrain:</strong> This mode is for painting the landscape with different terrain types like grass, water, and mountains.</li>
                            <li><strong>Pencil:</strong> This mode is for drawing freehand lines and shapes on top of your map, perfect for roads, rivers, or political borders.</li>
                        </ul>

                        <h5 class="text-md font-semibold text-white">Actions Panel</h5>
                        <p>This section gives you quick access to common map functions like <strong>Zoom</strong>, <strong>Undo/Redo</strong>, <strong>Eraser</strong>, and <strong>Center</strong> view.</p>

                        <h5 class="text-md font-semibold text-white">Terrain, Objects, and Text</h5>
                        <p>These sections work with a "select, then place" system.</p>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>To Place Terrain:</strong> Make sure the <strong>Terrain</strong> tool is active, select a terrain type, then click or drag on the canvas.</li>
                            <li><strong>To Place an Object or Text:</strong> Click an <strong>Object</strong> or the <strong>Text</strong> header. Your next single click on the map will place that item. The tool then reverts to Terrain mode.</li>
                        </ul>

                        <h4 class="text-lg font-bold text-white border-t border-gray-600 pt-3 mt-4">3. Graphics & Map Options (Bottom Panel)</h4>
                        <p>Click the "Graphics Options" button to find advanced settings like <strong>Layers</strong>, <strong>Grid Options</strong>, and <strong>Map Generation</strong>.</p>

                        <h4 class="text-lg font-bold text-white border-t border-gray-600 pt-3 mt-4">4. Saving and Loading</h4>
                        <p>Click the <strong>File Icon</strong> (üìÑ) at the top of the control panel to save your map as a PNG image or a ".json" project file (which you can load later).</p>

                        <h4 class="text-lg font-bold text-white border-t border-gray-600 pt-3 mt-4">5. Navigating the Canvas</h4>
                        <ul class="list-disc list-inside space-y-1 pl-4">
                            <li><strong>Pan:</strong> Hold down the <strong>right mouse button</strong> and drag.</li>
                            <li><strong>Zoom:</strong> Use your <strong>mouse wheel</strong>.</li>
                        </ul>
                        <div class="border-t border-gray-600 pt-3 mt-4 text-center text-xs text-gray-400">
                            <p>TTRPG HEX MAP MAKER by Wolfe.BT@TangentLLC</p>
                        </div>
                    </div>
                `;
                showContentModal("User's Guide", guideHTML);
            }

            function showContentModal(title, content, maxWidth = "max-w-2xl", height = "auto") {
                const existingModal = document.querySelector('.modal-backdrop');
                if(existingModal) existingModal.remove();

                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4';

                modalBackdrop.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-xl w-full ${maxWidth} text-white flex flex-col" style="height: ${height};">
                        <div class="flex justify-between items-center p-4 border-b border-gray-700 flex-shrink-0">
                            <h3 class="text-xl font-bold">${title}</h3>
                            <button id="modalClose" class="p-2 rounded-full hover:bg-gray-700">&times;</button>
                        </div>
                        <div class="p-6 overflow-y-auto flex-grow">
                            ${content}
                        </div>
                    </div>
                `;
                document.body.appendChild(modalBackdrop);
                modalBackdrop.querySelector('#modalClose').onclick = () => document.body.removeChild(modalBackdrop);
                modalBackdrop.onclick = (e) => {
                    if (e.target === modalBackdrop) {
                        document.body.removeChild(modalBackdrop);
                    }
                }
            }

            function showNamePromptModal(callback) {
                const existingModal = document.querySelector('.modal-backdrop');
                if(existingModal) existingModal.remove();

                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                modalBackdrop.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-white">
                        <h3 class="text-lg font-bold mb-4">Enter Map Name</h3>
                        <p class="mb-4 text-sm text-gray-400">Please provide a name for your map before saving.</p>
                        <input type="text" id="modalMapNameInput" class="w-full p-2 rounded border border-gray-600 bg-gray-700 text-white mb-4" placeholder="My Awesome Map">
                        <div class="flex justify-end gap-4">
                            <button id="modalSaveName" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 transition">Save</button>
                            <button id="modalCancelName" class="px-4 py-2 rounded bg-gray-600 hover:bg-gray-500 transition">Cancel</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalBackdrop);

                const nameInput = modalBackdrop.querySelector('#modalMapNameInput');
                nameInput.focus();

                modalBackdrop.querySelector('#modalCancelName').onclick = () => document.body.removeChild(modalBackdrop);

                const saveButton = modalBackdrop.querySelector('#modalSaveName');
                saveButton.onclick = () => {
                    const newName = nameInput.value.trim();
                    if (newName) {
                        mapName = newName;
                        mapNameInput.value = newName;
                        callback();
                        document.body.removeChild(modalBackdrop);
                    } else {
                        nameInput.classList.add('border-red-500');
                    }
                };

                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveButton.click();
                    }
                });
            }

            function showModal(message, onConfirm) {
                const existingModal = document.querySelector('.modal-backdrop');
                if(existingModal) existingModal.remove();

                const modalBackdrop = document.createElement('div');
                modalBackdrop.className = 'modal-backdrop fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
                modalBackdrop.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-white">
                        <p class="mb-6 text-center">${message}</p>
                        <div class="flex justify-end gap-4">
                            ${onConfirm ? `<button id="modalConfirm" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 transition">Confirm</button>` : ''}
                            <button id="modalCancel" class="px-4 py-2 rounded bg-gray-600 hover:bg-gray-500 transition">${onConfirm ? 'Cancel' : 'OK'}</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modalBackdrop);
                modalBackdrop.querySelector('#modalCancel').onclick = () => document.body.removeChild(modalBackdrop);
                if (onConfirm) {
                    modalBackdrop.querySelector('#modalConfirm').onclick = () => {
                        onConfirm();
                        document.body.removeChild(modalBackdrop);
                    };
                }
            }

            function updateMapKey() {
                if (mapKeyWindow.classList.contains('hidden')) return;

                const usedTerrains = new Set();
                const usedObjects = new Set();

                layers.forEach(layer => {
                    if (!layer.visible) return;
                    for (const key in layer.data) {
                        const hexData = layer.data[key];
                        if (hexData.terrain) {
                            usedTerrains.add(hexData.terrain);
                        }
                        if (hexData.objectKey) {
                            usedObjects.add(hexData.objectKey);
                        }
                    }
                });

                mapKeyContent.innerHTML = '';
                let contentHTML = '';

                if (usedTerrains.size > 0) {
                    contentHTML += '<h5 class="key-section-title">Terrain</h5>';
                    Array.from(usedTerrains).sort().forEach(terrainKey => {
                        const terrain = terrains[terrainKey];
                        if (terrain) {
                            contentHTML += `
                                <div class="key-item">
                                    <div class="key-swatch" style="background-image: url(${getPatternDataUri(terrain.pattern)})"></div>
                                    <span>${terrain.name}</span>
                                </div>
                            `;
                        }
                    });
                }

                if (usedObjects.size > 0) {
                    contentHTML += '<h5 class="key-section-title">Objects</h5>';
                    Array.from(usedObjects).sort().forEach(objectFullKey => {
                        const [mainCat, subCat, objKey] = objectFullKey.split('.');
                        const object = objectCategories[mainCat]?.[subCat]?.[objKey];
                        if (object) {
                            contentHTML += `
                                <div class="key-item">
                                    <div class="key-swatch">${object.symbol}</div>
                                    <span>${object.name}</span>
                                </div>
                            `;
                        }
                    });
                }

                if (contentHTML === '') {
                    contentHTML = '<p class="text-xs text-gray-400" style="grid-column: 1 / -1;">No items on map to display in key.</p>';
                }

                mapKeyContent.innerHTML = contentHTML;
            }

            function drawKeyOnContext(targetCtx, x, y) {
                const usedTerrains = new Set();
                const usedObjects = new Set();
                layers.forEach(layer => {
                    if (!layer.visible) return;
                    for (const key in layer.data) {
                        if (layer.data[key].terrain) usedTerrains.add(layer.data[key].terrain);
                        if (layer.data[key].objectKey) usedObjects.add(layer.data[key].objectKey);
                    }
                });

                if (usedTerrains.size === 0 && usedObjects.size === 0) return;

                const keyWidth = 150; // Match new narrow width
                const padding = 8;
                const itemHeight = 24;
                const swatchSize = 18;
                const titleHeight = 26;
                const sectionTitleHeight = 22;
                const textStyle = "12px 'Trebuchet MS'";
                const titleStyle = "bold 14px 'Trebuchet MS'";

                let terrainItems = Array.from(usedTerrains).sort();
                let objectItems = Array.from(usedObjects).sort();

                let keyHeight = padding * 2 + titleHeight;
                if(terrainItems.length > 0) keyHeight += sectionTitleHeight + terrainItems.length * itemHeight;
                if(objectItems.length > 0) keyHeight += sectionTitleHeight + objectItems.length * itemHeight;

                // Draw header background
                targetCtx.fillStyle = 'rgba(31, 41, 55, 0.9)';
                targetCtx.fillRect(x, y, keyWidth, titleHeight + padding);

                // Draw item backgrounds
                let itemBgY = y + titleHeight + padding;
                targetCtx.fillStyle = 'rgba(17, 24, 39, 0.7)';
                targetCtx.fillRect(x, itemBgY, keyWidth, keyHeight - titleHeight - padding);

                let currentY = y + padding;

                targetCtx.fillStyle = '#f9fafb';
                targetCtx.font = titleStyle;
                targetCtx.textAlign = 'left';
                targetCtx.textBaseline = 'middle';
                targetCtx.fillText('Map Key', x + padding, currentY + titleHeight / 2);
                currentY += titleHeight;

                const drawSection = (items, type) => {
                    if(items.length === 0) return;

                    targetCtx.font = "bold 13px 'Trebuchet MS'";
                    targetCtx.fillStyle = '#f9fafb';
                    targetCtx.fillText(type, x + padding, currentY + sectionTitleHeight / 2);
                    currentY += sectionTitleHeight;

                    items.forEach((itemKey) => {
                        const itemX = x + padding;
                        const itemY = currentY;

                        targetCtx.font = textStyle;
                        targetCtx.fillStyle = '#d1d5db';
                        targetCtx.textAlign = 'left';
                        targetCtx.textBaseline = 'middle';

                        if (type === 'Terrain') {
                            const terrain = terrains[itemKey];
                            if (terrain && terrain.canvasPattern) {
                                targetCtx.fillStyle = terrain.canvasPattern;
                                targetCtx.fillRect(itemX, itemY + (itemHeight - swatchSize) / 2, swatchSize, swatchSize);
                                targetCtx.strokeStyle = '#4b5563';
                                targetCtx.strokeRect(itemX, itemY + (itemHeight - swatchSize) / 2, swatchSize, swatchSize);
                                targetCtx.fillStyle = '#d1d5db';
                                targetCtx.fillText(terrain.name, itemX + swatchSize + 5, itemY + itemHeight / 2);
                            }
                        } else { // Objects
                            const [mainCat, subCat, objKey] = itemKey.split('.');
                            const object = objectCategories[mainCat]?.[subCat]?.[objKey];
                            if(object) {
                                targetCtx.font = `${swatchSize * 0.9}px Arial`;
                                targetCtx.textAlign = 'center';
                                targetCtx.fillText(object.symbol, itemX + swatchSize / 2, itemY + itemHeight / 2);

                                targetCtx.font = textStyle;
                                targetCtx.textAlign = 'left';
                                targetCtx.fillStyle = '#d1d5db';
                                targetCtx.fillText(object.name, itemX + swatchSize + 5, itemY + itemHeight / 2);
                            }
                        }
                        currentY += itemHeight;
                    });
                };

                drawSection(terrainItems, 'Terrain');
                drawSection(objectItems, 'Objects');
            }

            function showCreateAssetModal() {
                const assetManagerHTML = `
                    <div class="flex h-full">
                        <!-- Left Panel: Asset Type Selection -->
                        <div class="w-1/4 border-r border-gray-700 p-2 space-y-2">
                            <h4 class="text-lg font-bold mb-2 p-2">Asset Types</h4>
                            <button class="asset-type-tab active" data-tab="terrain">Custom Terrain</button>
                            <button class="asset-type-tab" data-tab="object">Custom Object</button>
                            <button class="asset-type-tab" data-tab="image">Image Asset</button>
                        </div>

                        <!-- Right Panel: Content for selected asset type -->
                        <div class="w-3/4 p-4">
                            <div id="asset-tab-content">
                                <!-- Content will be dynamically loaded here -->
                            </div>
                        </div>
                    </div>
                `;
                showContentModal("Asset Manager", assetManagerHTML, "max-w-4xl", "70vh");

                const tabContainer = document.querySelector('.modal-backdrop');
                const tabs = tabContainer.querySelectorAll('.asset-type-tab');
                const contentArea = tabContainer.querySelector('#asset-tab-content');

                function switchTab(tabName) {
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContainer.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

                    if (tabName === 'terrain') {
                        contentArea.innerHTML = `<div>Terrain content goes here</div>`;
                    } else if (tabName === 'object') {
                        contentArea.innerHTML = `<div>Object content goes here</div>`;
                    } else if (tabName === 'image') {
                        contentArea.innerHTML = `
                            <h5 class="text-xl font-bold mb-4">Create Image Asset</h5>
                            <div class="space-y-4">
                                <div>
                                    <label class="block mb-1 font-semibold">Asset Name</label>
                                    <input type="text" id="imageAssetName" class="w-full" placeholder="e.g., Castle Keep">
                                </div>
                                <div>
                                    <label class="block mb-1 font-semibold">Upload Image</label>
                                    <input type="file" id="imageAssetUpload" accept="image/*" class="w-full">
                                </div>
                                <div>
                                    <label class="block mb-1 font-semibold">Preview</label>
                                    <div id="imageAssetPreview" class="w-24 h-24 bg-gray-700 rounded flex items-center justify-center text-gray-400">
                                        <img src="" class="max-w-full max-h-full hidden"/>
                                        <span>None</span>
                                    </div>
                                </div>
                                <div>
                                    <label class="block mb-1 font-semibold">Description</label>
                                    <textarea id="imageAssetDescription" class="w-full" placeholder="e.g., A mighty fortress overlooking the valley."></textarea>
                                </div>
                                <div>
                                    <label class="block mb-1 font-semibold">Stats</label>
                                    <textarea id="imageAssetStats" class="w-full" placeholder="e.g., HP: 1000, AC: 20"></textarea>
                                </div>
                                <button id="saveImageAssetBtn" class="px-4 py-2 rounded bg-blue-600 hover:bg-blue-500 transition">Save Asset</button>
                            </div>
                        `;

                        const uploadInput = tabContainer.querySelector('#imageAssetUpload');
                        const previewImg = tabContainer.querySelector('#imageAssetPreview img');
                        const previewText = tabContainer.querySelector('#imageAssetPreview span');

                        uploadInput.addEventListener('change', (e) => {
                            const file = e.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    previewImg.src = event.target.result;
                                    previewImg.classList.remove('hidden');
                                    previewText.classList.add('hidden');
                                };
                                reader.readAsDataURL(file);
                            }
                        });

                        tabContainer.querySelector('#saveImageAssetBtn').addEventListener('click', () => {
                            const name = tabContainer.querySelector('#imageAssetName').value.trim();
                            const imgSrc = previewImg.src;
                            const description = tabContainer.querySelector('#imageAssetDescription').value.trim();
                            const stats = tabContainer.querySelector('#imageAssetStats').value.trim();

                            if (name && imgSrc) {
                                const key = name.toLowerCase().replace(/\s+/g, '-');

                                // Check if "Image" category exists, if not create it
                                if (!objectCategories["Image"]) {
                                    objectCategories["Image"] = { "Custom": {} };
                                }

                                objectCategories.Image.Custom[key] = {
                                    name,
                                    src: imgSrc,
                                    isImage: true,
                                    description,
                                    stats
                                };

                                populateSelectors();
                                showModal(`Asset '${name}' saved successfully!`);
                                // Optionally, close modal after saving
                                // document.querySelector('.modal-backdrop #modalClose').click();
                            } else {
                                showModal("Please provide a name and upload an image.");
                            }
                        });
                    }
                }

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => switchTab(tab.dataset.tab));
                });

                // Initialize with the first tab
                switchTab('terrain');
            }

            function addEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('contextmenu', e => e.preventDefault());

                canvas.addEventListener('mousedown', e => {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    if (e.button === 2) { // Right-click for panning
                        isPanning = true;
                        panStart = { x: e.clientX, y: e.clientY };
                        canvas.classList.add('panning');
                        return;
                    }

                    if (e.button === 0) { // Left-click for tools
                        if (nextClickAction) {
                            saveState();
                            applyTool(e, null, nextClickAction);
                            nextClickAction = null;
                            currentTool = 'terrain'; // Revert to terrain tool after placement
                            updateActiveSwatches();
                            return;
                        }

                        if (currentTool === 'inspector') {
                            const hex = pixelToHex(mouseX, mouseY);
                            const key = `${hex.q},${hex.r}`;
                            let content = `<div class="text-left"><strong>Hex:</strong> (${hex.q}, ${hex.r})<br>`;
                            layers.forEach(layer => {
                                if (layer.data[key]) {
                                    content += `<strong>Layer: ${layer.name}</strong><br>`;
                                    if(layer.data[key].terrain) content += `&nbsp;&nbsp;Terrain: ${terrains[layer.data[key].terrain].name}<br>`;
                                    if(layer.data[key].objectKey) {
                                        const [mainCat, subCat, objKey] = layer.data[key].objectKey.split('.');
                                        const object = objectCategories[mainCat][subCat][objKey];
                                        content += `&nbsp;&nbsp;Object: ${object.name}<br>`;
                                        if (object.description) content += `&nbsp;&nbsp;&nbsp;&nbsp;<em>${object.description}</em><br>`;
                                        if (object.stats) content += `&nbsp;&nbsp;&nbsp;&nbsp;<strong>Stats:</strong> ${object.stats}<br>`;
                                    }
                                    if(layer.data[key].text) content += `&nbsp;&nbsp;Text: ${layer.data[key].text}<br>`;
                                }
                            });
                            content += `</div>`;
                            showModal(content);
                            return;
                        }

                        const brushMode = currentTool === 'terrain' ? terrainBrushMode : pencilBrushMode;
                        const isShapeMode = ['line', 'rectangle', 'ellipse'].includes(brushMode);

                        if (isShapeMode) {
                            isDrawingShape = true;
                            shapeStartPoint = pixelToHex(mouseX, mouseY, currentTool === 'pencil');
                            saveState();
                        } else if (currentTool === 'terrain' && terrainBrushMode === 'spray') {
                            isPainting = true;
                            saveState();
                            currentFreestyleTerrainPath = { terrain: selectedTerrain, width: brushSize * 10, points: [pixelToHex(mouseX, mouseY, true)] };
                        } else if (currentTool === 'terrain' || currentTool === 'eraser') {
                            isPainting = true;
                            saveState();
                            applyTool(e);
                        } else if (currentTool === 'pencil') {
                            isPenciling = true;
                            saveState();
                            currentPencilPath = { type: 'freestyle', color: pencilColor, width: pencilWidth, points: [pixelToHex(mouseX, mouseY, true)] };
                        }
                    }
                });

                canvas.addEventListener('mousemove', e => {
                    if (isPanning) {
                        view.offsetX += e.clientX - panStart.x;
                        view.offsetY += e.clientY - panStart.y;
                        panStart = { x: e.clientX, y: e.clientY };
                        drawAll();
                        return;
                    }

                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    if (isDrawingShape) {
                        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                        let endPoint = pixelToHex(mouseX, mouseY, currentTool === 'pencil');
                        const startPoint = shapeStartPoint;

                        if (e.shiftKey && currentTool === 'pencil' && (pencilBrushMode === 'rectangle' || pencilBrushMode === 'ellipse')) {
                            const dx = endPoint.x - startPoint.x;
                            const dy = endPoint.y - startPoint.y;
                            const size = Math.max(Math.abs(dx), Math.abs(dy));
                            endPoint = {
                                x: startPoint.x + size * Math.sign(dx),
                                y: startPoint.y + size * Math.sign(dy)
                            };
                        }

                        previewCtx.save();
                        previewCtx.translate(view.offsetX, view.offsetY);
                        previewCtx.scale(view.zoom, view.zoom);

                        if (currentTool === 'terrain') {
                            const shapeHexes = getHexesForTool(e, endPoint);
                            shapeHexes.forEach(hex => {
                                const {x, y} = hexToPixel(hex.q, hex.r);
                                drawHex(previewCtx, x, y, 'rgba(100, 150, 255, 0.5)');
                            });
                        } else if (currentTool === 'pencil') {
                            previewCtx.beginPath();
                            previewCtx.strokeStyle = pencilColor;
                            previewCtx.lineWidth = pencilWidth;
                            const brushMode = pencilBrushMode;
                            if (brushMode === 'line') {
                                previewCtx.moveTo(startPoint.x, startPoint.y);
                                previewCtx.lineTo(endPoint.x, endPoint.y);
                            } else if (brushMode === 'rectangle') {
                                previewCtx.rect(startPoint.x, startPoint.y, endPoint.x - startPoint.x, endPoint.y - startPoint.y);
                            } else if (brushMode === 'ellipse') {
                                const rx = Math.abs(endPoint.x - startPoint.x) / 2;
                                const ry = Math.abs(endPoint.y - startPoint.y) / 2;
                                const cx = startPoint.x + (endPoint.x - startPoint.x) / 2;
                                const cy = startPoint.y + (endPoint.y - startPoint.y) / 2;
                                previewCtx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                            }
                            previewCtx.stroke();
                        }

                        previewCtx.restore();
                        drawAll();
                    } else if (isPainting) {
                        if (currentTool === 'terrain' && terrainBrushMode === 'spray' && currentFreestyleTerrainPath) {
                            currentFreestyleTerrainPath.points.push(pixelToHex(mouseX, mouseY, true));
                            drawAll();
                        } else {
                            applyTool(e);
                        }
                    } else if (isPenciling) { // Pencil freestyle
                        currentPencilPath.points.push(pixelToHex(mouseX, mouseY, true));
                        drawAll();
                    }
                });

                canvas.addEventListener('mouseup', e => {
                    if (e.button === 0) { // Left-click release
                        const brushMode = currentTool === 'terrain' ? terrainBrushMode : pencilBrushMode;
                        const isShapeMode = ['line', 'rectangle', 'ellipse'].includes(brushMode);

                        if (isDrawingShape && isShapeMode) {
                            let endPoint = pixelToHex(e.clientX - canvas.getBoundingClientRect().left, e.clientY - canvas.getBoundingClientRect().top, currentTool === 'pencil');
                            if (e.shiftKey && currentTool === 'pencil' && (pencilBrushMode === 'rectangle' || pencilBrushMode === 'ellipse')) {
                                const dx = endPoint.x - shapeStartPoint.x;
                                const dy = endPoint.y - shapeStartPoint.y;
                                const size = Math.max(Math.abs(dx), Math.abs(dy));
                                endPoint = {
                                    x: shapeStartPoint.x + size * Math.sign(dx),
                                    y: shapeStartPoint.y + size * Math.sign(dy)
                                };
                            }
                            if (currentTool === 'terrain') {
                                applyTool(e, endPoint);
                            } else if (currentTool === 'pencil') {
                                pencilPaths.push({
                                    type: pencilBrushMode,
                                    start: shapeStartPoint,
                                    end: endPoint,
                                    color: pencilColor,
                                    width: pencilWidth
                                });
                            }
                        }

                        if (isPainting) {
                            if (currentTool === 'terrain' && terrainBrushMode === 'spray' && currentFreestyleTerrainPath) {
                                freestyleTerrainPaths.push(currentFreestyleTerrainPath);
                                currentFreestyleTerrainPath = null;
                            }
                            isPainting = false;
                        }
                        if (isPenciling) {
                            isPenciling = false;
                            pencilPaths.push(currentPencilPath);
                            currentPencilPath = null;
                        }
                        isDrawingShape = false;
                        shapeStartPoint = null;
                        drawAll();
                    }

                    if (e.button === 2) { // Right-click release
                        isPanning = false;
                        canvas.classList.remove('panning');
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    if (isPenciling) {
                        if(currentPencilPath && currentPencilPath.points.length > 1) {
                            pencilPaths.push(currentPencilPath);
                        }
                        isPenciling = false;
                        currentPencilPath = null;
                    }
                    if (isPainting) {
                        if (currentTool === 'terrain' && terrainBrushMode === 'spray' && currentFreestyleTerrainPath) {
                            freestyleTerrainPaths.push(currentFreestyleTerrainPath);
                            currentFreestyleTerrainPath = null;
                        }
                        isPainting = false;
                    }
                    isPanning = false;
                    isDrawingShape = false;
                    canvas.classList.remove('panning');
                });

                canvas.addEventListener('wheel', e => {
                    e.preventDefault();
                    const zoomIntensity = 0.1;
                    const wheel = e.deltaY < 0 ? 1 : -1;
                    const zoom = Math.exp(wheel * zoomIntensity);

                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    const worldX = (mouseX - view.offsetX) / view.zoom;
                    const worldY = (mouseY - view.offsetY) / view.zoom;

                    const newZoom = Math.max(0.1, Math.min(5, view.zoom * zoom));

                    view.offsetX = mouseX - worldX * newZoom;
                    view.offsetY = mouseY - worldY * newZoom;
                    view.zoom = newZoom;

                    drawAll();
                });

                mapNameInput.addEventListener('input', (e) => { mapName = e.target.value; });
                brushSizeSlider.addEventListener('input', e => {
                    brushSize = parseInt(e.target.value);
                    brushSizeValue.textContent = brushSize;
                });
                zoomInBtn.addEventListener('click', () => { view.zoom = Math.min(5, view.zoom * 1.25); drawAll(); });
                zoomOutBtn.addEventListener('click', () => { view.zoom = Math.max(0.1, view.zoom / 1.25); drawAll(); });
                undoBtn.addEventListener('click', undo);
                redoBtn.addEventListener('click', redo);
                gridColorPicker.addEventListener('input', e => { gridColor = e.target.value; drawAll(); });
                gridVisibleCheckbox.addEventListener('change', e => {
                    const gridLayer = layers.find(l => l.type === 'grid');
                    if (gridLayer) {
                        gridLayer.visible = e.target.checked;
                        drawAll();
                        renderLayers();
                    }
                });
                toolTerrainBtn.addEventListener('click', () => { currentTool = 'terrain'; nextClickAction = null; updateActiveSwatches(); });
                toolPencilBtn.addEventListener('click', () => { currentTool = 'pencil'; nextClickAction = null; updateActiveSwatches(); });
                document.getElementById('toolInspectorBtn').addEventListener('click', () => { currentTool = 'inspector'; nextClickAction = null; updateActiveSwatches(); });
                terrainBrushModeSelect.addEventListener('change', (e) => { terrainBrushMode = e.target.value; });
                pencilBrushModeSelect.addEventListener('change', (e) => { pencilBrushMode = e.target.value; });
                pencilColorPicker.addEventListener('input', e => { pencilColor = e.target.value; });
                pencilWidthSlider.addEventListener('input', e => {
                    pencilWidth = parseInt(e.target.value);
                    pencilWidthValue.textContent = pencilWidth;
                });
                resetViewBtn.addEventListener('click', centerView);
                addLayerBtn.addEventListener('click', () => addNewLayer());
                deleteLayerBtn.addEventListener('click', deleteActiveLayer);
                textHeader.addEventListener('click', () => { nextClickAction = 'placeText'; updateActiveSwatches(); });
                generateBaseMapBtn.addEventListener('click', () => {
                    showModal("Generate a new blank map? This will delete all layers and current work.", () => {
                        generateBaseMap();
                    });
                });
                graphicsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    graphicsContent.classList.toggle('hidden');
                    graphicsChevron.classList.toggle('rotate-180');
                });
                fileMenuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    fileDropdownMenu.classList.toggle('hidden');
                });
                window.addEventListener('click', (e) => {
                    if (!fileMenuBtn.contains(e.target) && !fileDropdownMenu.contains(e.target)) {
                    fileDropdownMenu.classList.add('hidden');
                    }
                    if(!graphicsBtn.contains(e.target) && !graphicsContent.contains(e.target)) {
                        graphicsContent.classList.add('hidden');
                        graphicsChevron.classList.remove('rotate-180');
                    }
                });
                savePngBtn.addEventListener('click', () => promptForMapNameAndSave(saveAsPNGLogic));
                saveJsonBtn.addEventListener('click', () => promptForMapNameAndSave(saveAsJSONLogic));
                loadJsonBtn.addEventListener('click', () => loadJsonInput.click());
                loadJsonInput.addEventListener('change', loadFromJSON);
                accordionHeaders.forEach((header) => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        content.classList.toggle('hidden');
                        header.classList.toggle('collapsed');
                    });
                });
                collapseBtn.addEventListener('click', () => togglePanel(true));
                collapsedBar.addEventListener('click', () => togglePanel(false));
                userGuideBtn.addEventListener('click', showUserGuide);
                eraserBtn.addEventListener('click', () => { currentTool = 'eraser'; updateActiveSwatches(); });

                document.getElementById('addCustomTerrainBtn').addEventListener('click', () => {
                    const name = document.getElementById('customTerrainName').value.trim();
                    const color = document.getElementById('customTerrainColor').value;
                    if (name) {
                        const key = name.toLowerCase().replace(/\s+/g, '-');
                        terrains[key] = { name, color, isCustom: true };
                        populateSelectors();
                        document.getElementById('customTerrainName').value = '';
                    }
                });

                document.getElementById('addCustomObjectBtn').addEventListener('click', () => {
                    const name = document.getElementById('customObjectName').value.trim();
                    const symbol = document.getElementById('customObjectSymbol').value.trim();
                    if (name && symbol) {
                        const key = name.toLowerCase().replace(/\s+/g, '-');
                        objectCategories.Custom[key] = { name, symbol, isCustom: true };
                        populateSelectors();
                        document.getElementById('customObjectName').value = '';
                        document.getElementById('customObjectSymbol').value = '';
                    }
                });

                // Map Key Listeners
                mapKeyBtn.addEventListener('click', () => {
                    mapKeyWindow.classList.toggle('hidden');
                    updateMapKey();
                });
                mapKeyCloseBtn.addEventListener('click', () => mapKeyWindow.classList.add('hidden'));
                mapKeyHeader.addEventListener('mousedown', e => {
                    isDraggingKey = true;
                    keyDragOffset.x = e.clientX - mapKeyWindow.offsetLeft;
                    keyDragOffset.y = e.clientY - mapKeyWindow.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener('mousemove', e => {
                    if (isDraggingKey) {
                        let newX = e.clientX - keyDragOffset.x;
                        let newY = e.clientY - keyDragOffset.y;
                        const mainContainerRect = document.getElementById('main-container').getBoundingClientRect();
                        newX = Math.max(0, Math.min(newX, mainContainerRect.width - mapKeyWindow.offsetWidth));
                        newY = Math.max(0, Math.min(newY, mainContainerRect.height - mapKeyWindow.offsetHeight));
                        mapKeyWindow.style.left = `${newX}px`;
                        mapKeyWindow.style.top = `${newY}px`;
                    }
                });
                document.addEventListener('mouseup', () => {
                    isDraggingKey = false;
                });

                addNewMapBtn.addEventListener('click', () => {
                    showModal("Create a new map? This will clear your current map.", () => {
                        generateBaseMap();
                    });
                });

                createNewAssetBtn.addEventListener('click', () => {
                    showCreateAssetModal();
                });
            }

            async function initialize() {
                togglePanel(false); // Start with panel open

                addEventListeners();
                gridColorPicker.value = gridColor;
                const gridLayer = layers.find(l => l.type === 'grid');
                gridVisibleCheckbox.checked = gridLayer ? gridLayer.visible : true;
                updateUndoRedoButtons();
                updateActiveSwatches();

                requestAnimationFrame(async () => {
                    resizeCanvas();
                    await initializePatterns(ctx);
                    populateSelectors();
                    generateBaseMap();
                    centerView();
                });
            }

            // --- Initial Call ---
            initialize();
        });
    </script>
</body>
</html>
