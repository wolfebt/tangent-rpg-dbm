<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tangent SFF RPG Database Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Global Theme --- */
        :root {
            --bg-main: #212121;
            --bg-section: #333333;
            --bg-header: #1f2937;
            --bg-input: #424242;
            --bg-input-focus: #616161;
            --bg-hover: #4f4f4f;
            --bg-danger: #b71c1c;
            --bg-danger-hover: #d32f2f;
            
            --text-light: #f5f5f5;
            --text-dark: #212121;
            --text-subtle: #9e9e9e;
            
            --border-main: #9e9e9e;
            --border-subtle: #616161;
            --border-focus: #f5f5f5;

            --btn-primary-bg: #4f4f4f;
            --btn-primary-border: #9e9e9e;
            --btn-primary-hover-bg: #616161;
            --btn-primary-hover-border: #f5f5f5;

            --btn-danger-bg: #b71c1c;
            --btn-danger-border: #9e9e9e;
            --btn-danger-hover-bg: #d32f2f;
            --btn-danger-hover-border: #f5f5f5;
            
            --font-body: 'Roboto Condensed', sans-serif;
            --font-display: 'Roboto', sans-serif;

            --header-height: 4rem; /* Define header height for layout calculations */
            --sidebar-width: 180px; /* Define sidebar width, made narrower */
        }

        body {
            background-color: var(--bg-main);
            color: var(--text-light);
            font-family: 'Inter', sans-serif;
            padding-top: var(--header-height); /* Space for fixed header */
            overflow-x: hidden; /* Prevent horizontal scroll due to fixed sidebar */
            min-height: 100vh; /* Ensure body takes full viewport height */
            display: flex; /* Make body a flex container */
            flex-direction: column; /* Stack children vertically */
        }

        /* --- Global Components --- */
        .app-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--header-height); /* Explicit height */
            z-index: 40;
            background-color: var(--bg-header);
            border-bottom: 2px solid var(--border-subtle);
            padding: 0.5rem 1rem;
        }
        .app-header h1 {
            font-family: var(--font-display);
        }
        .category-menu-button {
            background-color: var(--bg-section);
            border: 2px solid var(--border-main);
            transition: all 0.2s ease;
        }
        .category-menu-button:hover {
            border-color: var(--border-focus);
        }
        .category-dropdown-menu {
            background-color: var(--bg-section);
            border: 2px solid var(--border-main);
            max-height: 70vh;
            overflow-y: auto;
        }
        .category-dropdown-menu a:hover, .category-dropdown-menu .submenu-container:hover > span {
            background-color: var(--bg-hover);
        }

        .data-table thead {
            background-color: var(--bg-section);
        }
        .data-table th {
            color: var(--text-subtle);
            font-family: var(--font-display);
            text-transform: uppercase;
            cursor: pointer;
        }
        .data-table tbody {
            background-color: var(--bg-header);
            border-color: var(--border-subtle);
        }
        .data-table tr {
            border-bottom: 1px solid var(--border-subtle);
        }
        .data-table tr:hover {
            background-color: var(--bg-hover);
        }

        .modal-backdrop {
            background-color: rgba(0,0,0,0.75);
        }
        .modal-content {
            background-color: var(--bg-section);
            border: 2px solid var(--border-main);
        }
        .modal-content h2 {
            font-family: var(--font-display);
            text-transform: uppercase;
        }
        
        .global-form-label {
            color: var(--text-subtle);
            text-transform: uppercase;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
            display: block;
        }
        .global-form-input {
            background-color: var(--bg-input);
            border: 1px solid var(--border-main);
            color: var(--text-light);
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.25rem;
            transition: all 0.2s ease;
        }
        .global-form-input:focus {
            outline: none;
            border-color: var(--border-focus);
            background-color: var(--bg-input-focus);
        }
        /* New style for display-only inputs */
        .global-form-input.display-only-input {
            background-color: var(--bg-header); /* Slightly darker to indicate non-editability */
            cursor: default;
            border-color: var(--border-subtle);
        }
        .global-form-input.display-only-input:focus {
            background-color: var(--bg-header);
            border-color: var(--border-subtle);
        }

        /* Style for wiki links */
        .wiki-link {
            color: #63b3ed; /* A shade of blue */
            text-decoration: underline;
            cursor: pointer;
        }
        .wiki-link:hover {
            color: #90cdf4; /* Lighter blue on hover */
        }

        /* Wiki View Specific Styles */
        main#main-content {
            flex-grow: 1; /* Allow it to take all available vertical space */
            display: flex; /* Make main-content a flex container */
            flex-direction: row; /* Arrange children (sidebar and content) horizontally */
            align-items: stretch; /* Stretch children to fill height */
            padding: 0; /* No padding on main-content itself */
            width: 100%; /* Ensure it takes full width */
        }

        .wiki-sidebar {
            position: fixed; /* Fixed position */
            left: 0; /* Stick to left edge of viewport */
            top: var(--header-height); /* Start below the header */
            bottom: 0; /* Extend to bottom of viewport */
            width: var(--sidebar-width); /* Fixed width */
            flex-shrink: 0;
            background-color: var(--bg-section);
            border-right: 2px solid var(--border-main); /* Border only on right */
            border-radius: 0; /* Remove rounded corners if it's full height */
            padding: 0.5rem; /* Smaller padding */
            overflow-y: auto;
            z-index: 30; /* Ensure it's above main content but below header */
            box-sizing: border-box; /* Include padding and border in the width */
        }

        .wiki-sidebar h3 {
            font-family: var(--font-display);
            text-transform: uppercase;
            font-size: 1rem; /* Smaller font for title */
            margin-bottom: 0.5rem;
            color: var(--text-light);
        }

        .wiki-sidebar ul {
            list-style: none;
            padding: 0;
            font-size: 0.85rem; /* Smaller font for list items */
        }

        .wiki-sidebar li {
            margin-bottom: 0.25rem;
        }

        .wiki-sidebar a {
            display: block;
            padding: 0.15rem 0.3rem; /* Smaller padding for links */
            color: var(--text-light);
            text-decoration: none;
            border-radius: 0.25rem;
        }

        .wiki-sidebar a:hover {
            background-color: var(--bg-hover);
        }

        .wiki-sidebar .wiki-tree-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .wiki-sidebar .wiki-tree-item .toggle-btn {
            background: none;
            border: none;
            color: var(--text-subtle);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 0;
            width: 1.5rem;
            text-align: center;
        }

        .wiki-sidebar .wiki-tree-item .toggle-btn:hover {
            color: var(--text-light);
        }

        .wiki-sidebar .wiki-tree-item-content {
            flex-grow: 1;
        }

        .wiki-sidebar .wiki-tree-children {
            margin-left: 1rem;
            border-left: 1px solid var(--border-subtle);
            padding-left: 0.5rem;
        }

        /* Wrapper for wiki content and its buttons */
        .wiki-content-area-wrapper {
            flex-grow: 1;
            margin-left: var(--sidebar-width); /* Push content to the right by sidebar's width */
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            padding: 0; /* No padding on this wrapper itself */
            height: 100%; /* Take full height of its parent */
        }

        .wiki-content {
            flex-grow: 1; /* Allow it to take available height */
            background-color: var(--bg-section);
            border: 2px solid var(--border-main); /* Keep its own border */
            border-radius: 0.25rem; /* Keep its own rounded corners */
            padding: 1.5rem; /* Apply padding directly to wiki-content */
            height: auto; /* Auto-fit height to content */
            overflow-y: auto;
            box-sizing: border-box;
        }

        .wiki-content h2 {
            font-family: var(--font-display);
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: var(--text-light);
            text-transform: uppercase;
        }

        .wiki-content h3 {
            font-family: var(--font-display);
            font-size: 1.8rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-light);
            text-transform: uppercase;
        }

        .wiki-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: var(--text-light);
        }


        .btn {
            font-family: var(--font-body);
            font-weight: bold;
            padding: 0.75rem 1rem;
            border: 2px solid;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            text-shadow: 1px 1px 2px #000;
            text-transform: uppercase;
        }
        .btn:hover { text-shadow: none; }
        
        .btn-primary {
            background-color: var(--btn-primary-bg);
            border-color: var(--btn-primary-border);
            color: var(--text-light);
        }
        .btn-primary:hover {
            background-color: var(--btn-primary-hover-bg);
            border-color: var(--btn-primary-hover-border);
        }
        .btn-danger {
            background-color: var(--bg-danger);
            border-color: var(--btn-danger-border);
            color: var(--text-light);
        }
        .btn-danger:hover {
            background-color: var(--bg-danger-hover);
            border-color: var(--btn-danger-hover-border);
        }
        .btn-secondary {
            background-color: var(--bg-section);
            border-color: var(--text-subtle);
            color: var(--text-light);
        }
        .btn-secondary:hover {
            background-color: var(--bg-hover);
            border-color: var(--border-focus);
        }

        /* --- Utility --- */
        .form-select-arrow {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%239CA3AF' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center; background-repeat: no-repeat; background-size: 1.5em;
        }
        .loader {
            border: 2px solid #f3f3f3; border-top: 2px solid #6b7280; border-radius: 50%;
            width: 16px; height: 16px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .auth-required {
            display: none;
        }

        /* --- Modal Data Menu Styling --- */
        .file-menu {
            position: relative;
            display: inline-block;
        }
        .file-menu-button {
             background-color: var(--bg-section);
            border: 2px solid var(--border-main);
            transition: all 0.2s ease;
            font-weight: bold;
            padding: 0.5rem 1rem;
            border-radius: 5px;
        }
        .file-menu-button:hover {
            border-color: var(--border-focus);
            background-color: var(--bg-hover);
        }
        .file-menu-dropdown {
            display: none;
            position: absolute;
            right: 0;
            background-color: var(--bg-section);
            min-width: 160px;
            border: 2px solid var(--border-main);
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 5px;
            padding: 0.5rem 0;
        }
        .file-menu-dropdown.show {
            display: block;
        }
        .file-menu-dropdown button, .file-menu-dropdown .submenu-container > span {
            color: var(--text-light);
            padding: 0.75rem 1rem;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
        }
        .file-menu-dropdown button:hover, .file-menu-dropdown .submenu-container:hover > span {
            background-color: var(--bg-hover);
        }
        .submenu-container {
            position: relative;
        }
        .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background-color: var(--bg-section);
            min-width: 160px;
            border: 2px solid var(--border-main);
            border-radius: 5px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        }
        .submenu-container:hover .submenu {
            display: block;
        }
    </style>
</head>
<body>

    <main id="main-content" class="w-full">
    </main>


    <div id="entry-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-3/4 max-w-6xl max-h-[90vh] overflow-y-auto flex flex-col">
            <div class="p-8">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="modal-title" class="text-2xl font-bold">Manage Entry</h2>
                    <div class="file-menu">
                        <button id="modal-data-btn" class="file-menu-button">DATA</button>
                        <div id="modal-data-dropdown" class="file-menu-dropdown">
                            </div>
                    </div>
                </div>
                <form id="entry-form">
                    <div id="form-fields" class="space-y-6">
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <div id="summary-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-4xl p-8 max-h-[90vh] overflow-y-auto">
            <h2 id="summary-title" class="text-2xl font-bold mb-6">Summary</h2>
            <div id="summary-content" class="space-y-4 text-gray-300 normal-case"></div>
            <div class="flex justify-end mt-8">
                <button id="summary-close-btn" class="btn btn-primary">Close</button>
            </div>
        </div>
    </div>


    <div id="confirm-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-md p-8">
            <h2 class="text-xl font-bold mb-4">Are you sure?</h2>
            <p id="confirm-message" class="text-gray-400 mb-6">This action cannot be undone.</p>
            <div class="flex justify-end gap-2">
                <button id="confirm-cancel-btn" class="btn btn-secondary">CANCEL</button>
                <button id="confirm-ok-btn" class="btn btn-danger">CONFIRM</button>
            </div>
        </div>
    </div>

    <div id="unsaved-changes-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-lg p-8">
            <h2 class="text-xl font-bold mb-4">Unsaved Changes</h2>
            <p class="text-gray-400 mb-6">You have unsaved changes. Do you want to save them before continuing?</p>
            <div class="flex justify-end gap-3">
                <button id="unsaved-cancel-btn" class="btn btn-secondary">CANCEL</button>
                <button id="unsaved-dismiss-btn" class="btn btn-danger">DISMISS CHANGES</button>
                <button id="unsaved-save-btn" class="btn btn-primary">SAVE & CONTINUE</button>
            </div>
        </div>
    </div>
    
    <div id="error-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-md p-8">
            <h2 class="text-xl font-bold mb-4 text-red-500">Error</h2>
            <p id="error-message" class="text-gray-400 mb-6">Something went wrong.</p>
            <div class="flex justify-end">
                <button id="error-ok-btn" class="btn btn-primary">OK</button>
            </div>
        </div>
    </div>

    <div id="help-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-50 p-4 hidden modal-backdrop">
        <div class="modal-content w-3/4 max-w-4xl max-h-[90vh] overflow-y-auto p-8">
            <h2 class="text-3xl font-bold mb-6 text-center">User Guide</h2>
            <div id="help-content" class="prose prose-invert max-w-none text-gray-300 normal-case space-y-4">
            </div>
            <div class="text-center font-bold text-sm pt-8 mt-6 border-t border-gray-600 normal-case" style="color: var(--text-subtle)">
                Wolfe.BT@TangentLLC
            </div>
            <div class="flex justify-end mt-8">
                <button id="help-close-btn" class="btn btn-primary">Close</button>
            </div>
        </div>
    </div>

    <div id="custom-modal" class="fixed inset-0 overflow-y-auto h-full w-full flex items-center justify-center z-[60] p-4 hidden modal-backdrop">
        <div class="modal-content w-full max-w-md p-8 text-center">
            <p id="modal-text" class="text-gray-200 mb-4 uppercase"></p>
            <div id="modal-auth-form" class="flex flex-col gap-2" style="display: none;">
                <input type="email" id="modal-email" placeholder="Email" class="global-form-input">
                <input type="password" id="modal-password" placeholder="Password" class="global-form-input">
                <div class="text-red-500 h-5 text-sm" id="modal-error-text"></div>
            </div>
            <div id="modal-choices" class="flex flex-col gap-2 max-h-48 overflow-y-auto mt-4"></div>
            <input type="text" id="modal-input" style="display: none;" class="global-form-input">
            <div class="flex justify-center gap-4 flex-wrap mt-4">
                <button id="modal-google-btn" style="display: none;" class="btn btn-primary">
                    Sign in with Google
                </button>
                <button id="modal-register-btn" style="display: none;" class="btn btn-primary">Register</button>
                <button id="modal-login-btn" style="display: none;" class="btn btn-primary">Login</button>
                <button id="modal-copy-btn" style="display: none;" class="btn btn-primary">Copy</button>
                <button id="modal-ok-btn" class="btn btn-primary">OK</button>
                <button id="modal-cancel-btn" style="display: none;" class="btn btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
    
    <input type="file" id="json-file-input" class="hidden" accept=".json">


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { 
            getAuth, onAuthStateChanged, signOut, 
            createUserWithEmailAndPassword, signInWithEmailAndPassword,
            GoogleAuthProvider, signInWithPopup,
            signInWithCustomToken, signInAnonymously
        } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, addDoc, deleteDoc, updateDoc, getDocs, getDoc, setDoc, setLogLevel, serverTimestamp, query, where, orderBy, limit } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

        // --- Firebase Configuration ---
        const firebaseConfig = {
          apiKey: "AIzaSyBA1CC4SXXtWM9UpU1XkAiBFr0RIgrPwGk",
          authDomain: "tangent-rpg-dbm.firebaseapp.com",
          projectId: "tangent-rpg-dbm",
          storageBucket: "tangent-rpg-dbm.appspot.com",
          messagingSenderId: "559983787369",
          appId: "1:559983787369:web:d6f3b87daaa82b23d211f8",
          measurementId: "G-G6NC09PXPC"
        };
        const appId = firebaseConfig.projectId;

        // --- Firebase Initialization ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        // --- Application State ---
        const appState = {
            userId: null,
            isAnonymous: true,
            authReady: false,
            currentCollection: null,
            currentSubcollection: null,
            editingDocId: null,
            confirmCallback: null,
            initialFormState: null,
            pendingNavigation: null,
            navigationContext: null,
            currentFolioData: null,
            activeFormForLoad: null,
            activeEquipmentTab: 'armoring',
            navigationHistory: [],
            navigationFuture: [],
            currentView: null, // e.g., { view: 'renderCategoryView', args: ['species'] }
            searchTerm: '',
            sortBy: 'name',
            sortDirection: 'asc',
            wikiEntries: [],
            currentWikiEntryId: null,
            activeListenerUnsubscribe: null, 
        };

        // --- RPG System Configuration ---
        const categoryConfig = {
            other: {
                label: 'DASHBOARD',
                viewType: 'button_grid'
            },
            rules_codex: {
                label: 'RULES CODEX',
                viewType: 'wiki',
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' },
                    guide: { type: 'textarea' },
                    parent: { type: 'select', source: 'rules_codex', label: 'Parent Entry', manageable: false },
                    order: { type: 'number', label: 'Order', default: 0 },
                }
            },
            values: {
                label: 'VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            secondary_values: {
                label: 'SECONDARY VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            tertiary_values: {
                label: 'TERTIARY VALUES',
                hideFromMenu: true,
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    mechanic: { type: 'textarea' },
                    cp: { type: 'number' }
                }
            },
            species: { 
                label: 'SPECIES',
                directory_columns: ['name', 'description', 'type'],
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    type: { type: 'multiselect', source: 'species_type', manageable: true },
                    size: { type: 'multiselect', source: 'species_size', manageable: true },
                    movement: { type: 'multiselect', source: 'species_movement', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    note: { type: 'textarea' },
                    cp: { type: 'readonlytext', label: 'CP' }
                },
                subcategories: {
                    species_type: { 
                        label: 'TYPES', 
                        directory_columns: ['name', 'description', 'modifier'],
                        fields: { 
                            name: { type:'text', required: true},
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP'} 
                        } 
                    },
                    species_size: { 
                        label: 'SIZES', 
                        directory_columns: ['name', 'description', 'modifier'],
                        fields: { 
                            name: { type:'text', required: true},
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            scaling: { type: 'number', label: 'Scaling' },
                            height_length_range: { type: 'text', label: 'Height/Length Range' },
                            weight_range: { type: 'text', label: 'Weight Range' },
                            reach: { type: 'text', label: 'Reach' },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP'} 
                        } 
                    },
                    species_movement: { 
                        label: 'MOVEMENTS', 
                        directory_columns: ['name', 'description', 'cp'],
                        fields: { 
                            name: { type:'text', required: true}, 
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true},
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP' } 
                        } 
                    },
                }
            },
            factions: { 
                label: 'FACTIONS', 
                directory_columns: ['name', 'description', 'society'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true },
                    society: { type: 'select', source: 'societies', manageable: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    attitude: { type: 'textarea' },
                    goals: { type: 'textarea' },
                    social_strengths: { type: 'textarea' },
                    social_weaknesses: { type: 'textarea' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            origins: { 
                label: 'ORIGINS', 
                directory_columns: ['name', 'description'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    trait: { type: 'multiselect', source: 'trait', manageable: true },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    trait: { 
                        label: 'TRAITS', 
                        directory_columns: ['name', 'description', 'cp'],
                        fields: { 
                            name: { type:'text', required: true}, 
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                            meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            description: { type:'textarea', aiEnabled: true}, 
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' },
                            cp: { type: 'readonlytext', label: 'TOTAL CP' } 
                        } 
                    },
                }
            },
            occupations: { 
                label: 'OCCUPATIONS',
                directory_columns: ['name', 'description'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    trait: { type: 'multiselect', source: 'trait', manageable: true },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            disadvantages: { 
                label: 'DISADVANTAGES',
                directory_columns: ['name', 'description', 'cp'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    cp: { type: 'number'},
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            features: { 
                label: 'FEATURES',
                directory_columns: ['name', 'type', 'description', 'cp'], 
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', options: ['ability', 'combat', 'meta', 'general', 'karma', 'skill', 'special'] },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true},
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    cp: { type: 'readonlytext', label: 'TOTAL CP' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            skills: { 
                label: 'SKILLS',
                directory_columns: ['name', 'type', 'subtype', 'description'],
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', options: ['mental', 'physical', 'social', 'combat', 'meta'], required: true },
                    subtype: { type: 'select' },
                    is_specialization: { type: 'boolean', label: 'SPECIALIZATION' },
                    base_skill: { type: 'select', source: 'skills', label: 'BASE SKILL' },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                } 
            },
            prerequisite: {
                label: 'PREREQUISITES',
                hideFromMenu: true,
                directory_columns: ['name', 'aspect', 'aspect_subtype', 'value', 'note', 'cp'],
                fields: {
                    name: { type: 'text', required: true},
                    description: { type: 'textarea', aiEnabled: true},
                    aspect: { type: 'select', options: ['attribute', 'skill', 'combat', 'meta', 'other'] },
                    aspect_subtype: { type: 'select' },
                    value: { type: 'number' },
                    dc: { type: 'number', label: 'DC' },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'},
                    cp: { type: 'number' }
                }
            },
            modifier: {
                label: 'MODIFIERS',
                hideFromMenu: true,
                directory_columns: ['name', 'aspect', 'aspect_subtype', 'value', 'note', 'cp'],
                fields: {
                    name: { type: 'text', required: true},
                    description: { type: 'textarea', aiEnabled: true},
                    aspect: { type: 'select', options: ['attribute', 'skill', 'combat', 'meta', 'other'] },
                    aspect_subtype: { type: 'select' },
                    value: { type: 'number' },
                    modifier_type: { type: 'radio', label: 'Modifier Type', options: ['constant', 'situational', 'optional', 'temporary'] },
                    dc: { type: 'number', label: 'DC' },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'},
                    cp: { type: 'number' }
                }
            },
            augmentations: { 
                label: 'AUGMENTATIONS', 
                directory_columns: ['name', 'type', 'description', 'design_dc'],
                fields: { 
                    name: { type:'text', required: true},
                    type: { type: 'select', source: 'augmentation_type', manageable: true },
                    classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                    location: { type: 'multiselect', source: 'body_location', manageable: true },
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    creator: { type: 'multiselect', source: 'creator', manageable: true },
                    design: { type: 'multiselect', source: 'design', manageable: true },
                    component: { type: 'multiselect', source: 'component', manageable: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true},
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                    critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                    cost: { type: 'number', label: 'Cost' },
                    availability: { type: 'select', source: 'availability', manageable: true },
                    cr: { type: 'number', label: 'CR' },
                    restricted: { type: 'boolean', label: 'Restricted' },
                    design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                    cp: { type: 'number' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    augmentation_type: { 
                        label: 'AUGMENTATION TYPES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            invocations: {
                label: 'INVOCATIONS',
                directory_columns: ['name', 'description', 'discipline', 'meta_skill', 'design_dc'],
                fields: {
                    name: { type: 'text', required: true },
                    description: { type: 'textarea', aiEnabled: true },
                    discipline: { type: 'select', source: 'discipline', manageable: true },
                    meta_skill: { type: 'select', source: 'skills_meta', label: 'Meta Skill' },
                    area: { type: 'multiselect', source: 'area', manageable: true },
                    effect: { type: 'multiselect', source: 'effect', manageable: true },
                    range: { type: 'multiselect', source: 'range', manageable: true },
                    target: { type: 'multiselect', source: 'target', manageable: true },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                    critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                    design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                    mechanic: { type: 'textarea' },
                    note: { type: 'textarea' }
                },
                subcategories: {
                    discipline: { 
                        label: 'DISCIPLINES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            equipment: { 
                label: 'EQUIPMENT', 
                viewType: 'multi-table',
                tables: {
                    armoring: {
                        label: 'Armoring',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Armor Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            material: { type: 'multiselect', source: 'material', manageable: true },
                            location: { type: 'multiselect', source: 'body_location', manageable: true },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            resistance: { type: 'multiselect', source: 'resistance', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    weaponry: {
                        label: 'Weaponry',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Weapon Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            special: { type: 'multiselect', source: 'special', manageable: true, label: 'Special' },
                            area: { type: 'multiselect', source: 'area', manageable: true },
                            effect: { type: 'multiselect', source: 'effect', manageable: true },
                            range: { type: 'multiselect', source: 'range', manageable: true },
                            target: { type: 'multiselect', source: 'target', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            accuracy: { type: 'number' },
                            ap: { type: 'number', label: 'AP' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            attack_rate: { type: 'text', label: 'Rate of Fire' },
                            critical_score: { type: 'text', label: 'Critical Score' },
                            critical_effect: { type: 'multiselect', source: 'critical_effect', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            wielding: { type: 'select', options: ['One-Handed', 'Two-Handed', 'Versatile', 'Independent', 'Mounted'] },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    mecha: {
                        label: 'Mecha',
                        directory_columns: ['name', 'tl', 'ml', 'description', 'cost', 'design_dc'],
                        fields: {
                            name: { type: 'text', required: true, label: 'Mecha Name' },
                            description: { type: 'textarea' },
                            tl: { type: 'number', label: 'TL' },
                            ml: { type: 'number', label: 'ML' },
                            cost: { type: 'number' },
                            availability: { type: 'select', source: 'availability', manageable: true },
                            design_dc: { type: 'readonlytext', label: 'DESIGN DC' },
                            size: { type: 'multiselect', source: 'species_size', manageable: true },
                            height: { type: 'number' },
                            weight: { type: 'number' },
                            quality: { type: 'select', options: ['Bad', 'Poor', 'Standard', 'Good', 'Exceptional', 'Mastercrafted'] },
                            durability: { type: 'number' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            skill: { type: 'select', source: 'skills', manageable: true },
                            origin: { type: 'multiselect', source: 'origins', manageable: true },
                            creator: { type: 'multiselect', source: 'creator', manageable: true },
                            design: { type: 'multiselect', source: 'design', manageable: true },
                            classification: { type: 'multiselect', source: 'classification', manageable: true, label: 'Classification' },
                            personnel: { type: 'text' },
                            cargo: { type: 'text' },
                            speed: { type: 'text' },
                            maneuverability: { type: 'text' },
                            control: { type: 'select', options: ['Auto', 'Remote', 'Pilot', 'Crew'] },
                            component: { type: 'multiselect', source: 'component', manageable: true },
                            critical_success_effect: { type: 'multiselect', source: 'critical_success_effect', manageable: true },
                            critical_failure_effect: { type: 'multiselect', source: 'critical_failure_effect', manageable: true },
                            component_slots: { type: 'number', label: 'Component Slots' },
                            modes: { type: 'multiselect', source: 'mode', manageable: true, label: 'Modes' },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                },
                subcategories: {
                    availability: { 
                        label: 'AVAILABILITY', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    material: { 
                        label: 'MATERIALS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' }, 
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    resistance: { 
                        label: 'RESISTANCES', 
                        directory_columns: ['name', 'type', 'value', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            type: { type: 'select', source: 'resistance_type', manageable: true },
                            value: { type: 'number' },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    resistance_type: { 
                        label: 'RESISTANCE TYPES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' }
                        }
                    },
                    special: { 
                        label: 'SPECIAL',
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        } 
                    },
                    mode: { 
                        label: 'MODES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    critical_effect: { 
                        label: 'CRITICAL EFFECTS', 
                        fields: { 
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            effect: { type: 'multiselect', source: 'effect', manageable: true },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    component: { 
                        label: 'COMPONENTS',
                        directory_columns: ['name', 'description', 'cost'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            equipment: { type: 'multiselect', source: 'all_equipment', label: 'Equipment', manageable: true },
                            cost: { type: 'number' }
                        }
                    },
                    creator: {
                        label: 'CREATORS',
                        directory_columns: ['name', 'description'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    design: {
                        label: 'DESIGNS',
                        directory_columns: ['name', 'description'],
                        fields: {
                            name: { type: 'text', required: true },
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    classification: { 
                        label: 'CLASSIFICATIONS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' }, 
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' } 
                        }
                    },
                    gear_category: { 
                        label: 'CATEGORIES', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            dc: { type: 'number', label: 'DC' },
                            prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                            modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    },
                    body_location: { 
                        label: 'BODY LOCATIONS', 
                        directory_columns: ['name', 'description'],
                        fields: { 
                            name: { type: 'text', required: true }, 
                            description: { type: 'textarea' },
                            mechanic: { type: 'textarea' },
                            note: { type: 'textarea' }
                        }
                    }
                }
            },
            societies: { 
                label: 'SOCIETIES', 
                directory_columns: ['name', 'description', 'tech_level', 'meta_level'],
                fields: { 
                    name: { type:'text', required: true}, 
                    description: { type:'textarea', aiEnabled: true},
                    tech_level: { type: 'select', label: 'Tech Level', options: [0, 1, 2, 3, 4, 5] },
                    meta_level: { type: 'select', label: 'Meta Level', options: [0, 1, 2, 3, 4, 5] },
                    prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true },
                    modifier: { type: 'multiselect', source: 'modifier', manageable: true },
                    agriculture: { type: 'multiselect', source: 'society_agriculture', manageable: true },
                    architecture: { type: 'multiselect', source: 'society_architecture', manageable: true },
                    biotechnology: { type: 'multiselect', source: 'society_biotechnology', manageable: true },
                    commerce: { type: 'multiselect', source: 'society_commerce', manageable: true },
                    communication: { type: 'multiselect', source: 'society_communication', manageable: true },
                    devices: { type: 'multiselect', source: 'society_devices', manageable: true },
                    education: { type: 'multiselect', source: 'society_education', manageable: true },
                    energy: { type: 'multiselect', source: 'society_energy', manageable: true },
                    manufacturing: { type: 'multiselect', source: 'society_manufacturing', manageable: true },
                    materials: { type: 'multiselect', source: 'society_materials', manageable: true },
                    medicine: { type: 'multiselect', source: 'society_medicine', manageable: true },
                    synthetics: { type: 'multiselect', source: 'society_synthetics', manageable: true, label: 'Synthetics' },
                    weaponry: { type: 'multiselect', source: 'society_weaponry', manageable: true },
                    mechanic: { type: 'textarea'},
                    note: { type: 'textarea'}
                },
                subcategories: {
                    society_agriculture: { label: 'AGRICULTURE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_architecture: { label: 'ARCHITECTURE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_biotechnology: { label: 'BIOTECHNOLOGY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_commerce: { label: 'COMMERCE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text', required: true }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_communication: { label: 'COMMUNICATION', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_devices: { label: 'DEVICES', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_education: { label: 'EDUCATION', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_energy: { label: 'ENERGY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_manufacturing: { label: 'MANUFACTURING', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_materials: { label: 'MATERIALS', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_medicine: { label: 'MEDICINE', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_society: { label: 'SOCIETY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_synthetics: { label: 'SYNTHETICS', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }},
                    society_weaponry: { label: 'WEAPONRY', directory_columns: ['name', 'description', 'level'], fields: { name: { type: 'text' }, description: { type: 'textarea', aiEnabled: true }, level: { type: 'select', options: [0, 1, 2, 3, 4, 5] }, prerequisite: { type: 'multiselect', source: 'prerequisite', manageable: true }, modifier: { type: 'multiselect', source: 'modifier', manageable: true }, note: { type: 'textarea' }, mechanic: { type: 'textarea'} }}}
            }
        };

        // --- Field Order Configuration ---
        const masterFieldOrder = [
            'name', 'description', 'mechanic', 'guide', 'effect_type', 'value', 'shape', 'dimensions', 'number_of_targets',
            'tech_level', 'meta_level', 'class', 'classification', 'category', 'type', 'subtype',
            'cr', 'cost', 'availability', 'dc', 'cp', 'restricted', 'component_slots',
            'location', 'size', 'height', 'weight', 'scaling', 'height_length_range', 'weight_range', 'personnel', 'cargo', 'reach', 'weapon_effect', 'wielding',
            'movement', 'speed',
            'quality', 'material', 'durability', 'resistance',
            'prerequisite', 'modifier', 'modifier_type', 'abilities',
            'ammunition_type', 'ap', 'area', 'attack_rate', 'damage', 'damage_type', 'damage_value', 'effect', 'effect_subtype', 'range', 'target', 'critical_score', 'critical_success_effect', 'critical_failure_effect', 'critical_effect',
            'skill', 'meta_skill', 'faction_skill', 'profession_skill', 'species_skill', 'is_specialization', 'base_skill', 'discipline', 'accuracy', 'control', 'maneuverability',
            'faction_feat', 'recommended_feature',
            'trait',
            'attitude', 'social_strengths', 'social_weaknesses', 'society', 'goals',
            'component', 'integration',
            'special',
            'modes', 'note', 'parent', 'order' 
        ];
        
        // --- UI Elements ---
        const mainContentContainer = document.getElementById('main-content');
        const entryModal = document.getElementById('entry-modal');
        const modalTitle = document.getElementById('modal-title');
        const entryForm = document.getElementById('entry-form');
        const formFieldsContainer = document.getElementById('form-fields');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmMessage = document.getElementById('confirm-message');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const unsavedChangesModal = document.getElementById('unsaved-changes-modal');
        const unsavedCancelBtn = document.getElementById('unsaved-cancel-btn');
        const unsavedDismissBtn = document.getElementById('unsaved-dismiss-btn');
        const unsavedSaveBtn = document.getElementById('unsaved-save-btn');
        const errorModal = document.getElementById('error-modal');
        const errorMessage = document.getElementById('error-message');
        const errorOkBtn = document.getElementById('error-ok-btn');
        const helpModal = document.getElementById('help-modal');
        const helpContent = document.getElementById('help-content');
        const helpCloseBtn = document.getElementById('help-close-btn');
        const customModal = document.getElementById('custom-modal');
        const summaryModal = document.getElementById('summary-modal');
        const summaryCloseBtn = document.getElementById('summary-close-btn');
        const jsonFileInput = document.getElementById('json-file-input');

        // --- Authentication & Navigation---
        const viewFunctions = { renderCategoryView, renderManagementView };
        
        function navigateTo(viewDescriptor, pushState = true) {
            if (pushState && appState.currentView) {
                appState.navigationHistory.push(appState.currentView);
                appState.navigationFuture = []; // Clear future on new navigation
            }
            appState.currentView = viewDescriptor;

            const { view, args } = viewDescriptor;
            if (viewFunctions[view]) {
                viewFunctions[view](...args);
            }

            try {
                sessionStorage.setItem('navigationHistory', JSON.stringify(appState.navigationHistory));
                sessionStorage.setItem('navigationFuture', JSON.stringify(appState.navigationFuture));
                sessionStorage.setItem('currentView', JSON.stringify(appState.currentView));
            } catch (e) {
                console.warn("Could not save navigation state to sessionStorage.", e);
            }

            updateNavButtonsState();
        }

        function goBack() {
            if (appState.navigationHistory.length > 0) {
                if (appState.currentView) {
                    appState.navigationFuture.unshift(appState.currentView);
                }
                const previousView = appState.navigationHistory.pop();
                navigateTo(previousView, false);
            }
        }

        function goForward() {
            if (appState.navigationFuture.length > 0) {
                if (appState.currentView) {
                    appState.navigationHistory.push(appState.currentView);
                }
                const nextView = appState.navigationFuture.shift();
                navigateTo(nextView, false);
            }
        }

        function updateNavButtonsState() {
            const backBtn = document.getElementById('back-btn');
            const forwardBtn = document.getElementById('forward-btn');
            if (backBtn) {
                backBtn.disabled = appState.navigationHistory.length === 0;
            }
            if (forwardBtn) {
                forwardBtn.disabled = appState.navigationFuture.length === 0;
            }
        }

        function requestNavigation(viewDescriptor) {
            if (isFormDirty()) {
                appState.pendingNavigation = viewDescriptor;
                unsavedChangesModal.classList.remove('hidden');
            } else {
                closeModal(true);
                if (viewDescriptor) {
                    navigateTo(viewDescriptor);
                }
            }
        }


        async function handleLogin() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Error during Google sign-in:", error);
                if (error.code === 'auth/unauthorized-domain') {
                    showError("This domain is not authorized for Google Sign-In. Please add it to the authorized domains in your Firebase Authentication settings.");
                } else {
                    showError("Could not sign in with Google. Please try again.");
                }
            }
        }

        async function handleLogout() {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Error signing out:", error);
                showError("An error occurred while signing out.");
            }
        }

        function updateUIAfterAuthChange() {
            const authContainer = document.getElementById('auth-container');
            const userIdDisplay = document.getElementById('userIdDisplay');

            if (authContainer) {
                authContainer.innerHTML = ''; 
                if (appState.isAnonymous) {
                    const loginButton = document.createElement('button');
                    loginButton.className = 'btn btn-primary !py-1 !px-3';
                    loginButton.textContent = 'LOGIN';
                    loginButton.addEventListener('click', handleLogin);
                    authContainer.appendChild(loginButton);
                } else {
                    const logoutButton = document.createElement('button');
                    logoutButton.className = 'btn btn-secondary !py-1 !px-3';
                    logoutButton.textContent = 'LOGOUT';
                    logoutButton.addEventListener('click', handleLogout);
                    authContainer.appendChild(logoutButton);
                }
            }
            
            if(userIdDisplay) {
                 userIdDisplay.textContent = appState.isAnonymous ? 'ANONYMOUS' : (auth.currentUser?.email || appState.userId);
            }

            const authRequiredElements = document.querySelectorAll('.auth-required');
            authRequiredElements.forEach(el => {
                el.style.display = appState.isAnonymous ? 'none' : '';
            });

            // Update interactivity of table titles based on auth state
            const allTableTitles = document.querySelectorAll('h2[id^="table-title-"]');
            allTableTitles.forEach(title => {
                if (appState.isAnonymous) {
                    title.style.cursor = 'default';
                    title.classList.remove('hover:underline');
                } else {
                    title.style.cursor = 'pointer';
                    title.classList.add('hover:underline');
                }
            });
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                appState.userId = user.uid;
                appState.isAnonymous = user.isAnonymous;

                if (!appState.authReady) {
                    appState.authReady = true;
                    try {
                        await populateRulesCodexMap();
                        
                        const savedHistory = sessionStorage.getItem('navigationHistory');
                        const savedFuture = sessionStorage.getItem('navigationFuture');
                        const savedView = sessionStorage.getItem('currentView');

                        if (savedView) {
                            appState.navigationHistory = savedHistory ? JSON.parse(savedHistory) : [];
                            appState.navigationFuture = savedFuture ? JSON.parse(savedFuture) : [];
                            navigateTo(JSON.parse(savedView), false);
                        } else {
                            navigateTo({ view: 'renderCategoryView', args: ['other'] });
                        }
                    } catch (error) {
                         if (error.code === 'permission-denied') {
                            showError("CRITICAL ERROR: Firestore rules are not set up for public read. Please update your Firestore security rules to allow read access.");
                        } else {
                            showError(`An unexpected error occurred during startup: ${error.message}`);
                        }
                        console.error("Startup Error:", error);
                    }
                } else {
                    updateUIAfterAuthChange();
                    if (appState.currentView) {
                        const { view, args } = appState.currentView;
                        if(viewFunctions[view]) viewFunctions[view](...args);
                    }
                }
            } else {
                appState.isAnonymous = true;
                appState.userId = null;
                signInAnonymously(auth).catch(err => {
                    console.error("Failed to re-establish anonymous session:", err);
                    if (err.code === 'auth/admin-restricted-operation') {
                        showError("CRITICAL ERROR: Anonymous sign-in is not enabled in your Firebase project. Please go to Authentication -> Sign-in method in the Firebase console and enable the 'Anonymous' provider.");
                    } else {
                        showError("Your session has ended. Please refresh the page.");
                    }
                });
            }
        });
        
        function getFormDataObject(formElement) {
            const form = formElement || document.getElementById('entry-form');
            if (!form) return {};
            const formData = new FormData(form);
            const data = {};
            for (let [key, value] of formData.entries()) {
                if (data[key]) {
                    if (!Array.isArray(data[key])) {
                        data[key] = [data[key]];
                    }
                    data[key].push(value);
                } else {
                    data[key] = value;
                }
            }
            return data;
        }
        
        function getFormState(form) {
            return JSON.stringify(getFormDataObject(form));
        }

        function isFormDirty() {
            if (!entryModal || entryModal.classList.contains('hidden')) return false;
            if (appState.initialFormState === null) return false;
            return appState.initialFormState !== getFormState(document.getElementById('entry-form'));
        }

        function handleManageClick(sourceKey) {
            appState.navigationContext = {
                from: 'modal',
                parentCollection: appState.currentCollection,
                parentSubcollection: appState.currentSubcollection,
                docId: appState.editingDocId,
                data: getFormDataObject(document.getElementById('entry-form'))
            };

            const parentForSource = Object.keys(categoryConfig).find(key => 
                (categoryConfig[key].subcategories && categoryConfig[key].subcategories[sourceKey])
            ) || sourceKey;

            const viewDescriptor = { view: 'renderManagementView', args: [sourceKey, parentForSource] };
            
            if (isFormDirty()) {
                appState.pendingNavigation = viewDescriptor;
                unsavedChangesModal.classList.remove('hidden');
            } else {
                closeModal(true);
                navigateTo(viewDescriptor);
            }
        }
        
        // --- Navigation & View Rendering ---
        
        function renderAppHeader(activeCategoryKey) {
            const existingHeader = document.querySelector('.app-header');
            if(existingHeader) existingHeader.remove();

            const headerContainer = document.createElement('header');
            headerContainer.className = 'app-header flex justify-between items-center gap-4';

            const leftCol = document.createElement('div');
            leftCol.className = 'flex-1';
            
            const dropdownContainer = document.createElement('div');
            dropdownContainer.className = 'relative';

            const menuButton = document.createElement('button');
            menuButton.id = 'category-menu-button';
            menuButton.className = 'category-menu-button font-bold py-1 px-2 rounded-lg inline-flex items-center w-full max-w-xs justify-between';
            menuButton.innerHTML = `
                <span>${categoryConfig[activeCategoryKey]?.label.toUpperCase() || 'DASHBOARD'}</span>
            `;

            const dropdownMenu = document.createElement('div');
            dropdownMenu.id = 'category-dropdown-menu';
            dropdownMenu.className = 'category-dropdown-menu hidden absolute left-0 mt-2 w-auto min-w-max rounded-md shadow-lg z-20 whitespace-nowrap';
            
            const dropdownList = document.createElement('div');
            dropdownList.className = 'py-1';

            const dashboardLink = document.createElement('a');
            dashboardLink.href = '#';
            dashboardLink.className = 'block px-4 py-2 text-sm text-gray-300 hover:text-white font-bold';
            dashboardLink.textContent = 'DASHBOARD';
            dashboardLink.addEventListener('click', (e) => {
                e.preventDefault();
                requestNavigation({ view: 'renderCategoryView', args: ['other'] });
                dropdownMenu.classList.add('hidden');
            });
            dropdownList.appendChild(dashboardLink);

            const mainCategories = Object.keys(categoryConfig).filter(key => !categoryConfig[key].hideFromMenu && key !== 'other');
            
            mainCategories.forEach(key => {
                const link = document.createElement('a');
                link.href = '#';
                link.className = 'block px-4 py-2 text-sm text-gray-300 hover:text-white';
                link.textContent = categoryConfig[key].label.toUpperCase();
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    requestNavigation({ view: 'renderCategoryView', args: [key] });
                    dropdownMenu.classList.add('hidden');
                });
                dropdownList.appendChild(link);
            });


            dropdownMenu.appendChild(dropdownList);

            menuButton.addEventListener('click', () => {
                dropdownMenu.classList.toggle('hidden');
            });
            
            dropdownContainer.appendChild(menuButton);
            dropdownContainer.appendChild(dropdownMenu);
            leftCol.appendChild(dropdownContainer);
            headerContainer.appendChild(leftCol);

            const centerCol = document.createElement('div');
            centerCol.className = 'flex-grow flex justify-center items-center gap-4';

            const backButton = document.createElement('button');
            backButton.id = 'back-btn';
            backButton.className = 'btn btn-secondary !p-2 disabled:opacity-50 disabled:cursor-not-allowed';
            backButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/></svg>`;
            backButton.addEventListener('click', goBack);

            const titleContainer = document.createElement('div');
            titleContainer.className = 'text-center';
            titleContainer.innerHTML = `
                <h1 class="text-xl font-bold text-gray-100 whitespace-nowrap">TANGENT SFF RPG</h1>
                <p class="text-xs text-gray-400 uppercase">DATABASE MANAGER</p>`;

            const forwardButton = document.createElement('button');
            forwardButton.id = 'forward-btn';
            forwardButton.className = 'btn btn-secondary !p-2 disabled:opacity-50 disabled:cursor-not-allowed';
            forwardButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/></svg>`;
            forwardButton.addEventListener('click', goForward);

            centerCol.appendChild(backButton);
            centerCol.appendChild(titleContainer);
            centerCol.appendChild(forwardButton);
            headerContainer.appendChild(centerCol);
            
            const rightCol = document.createElement('div');
            rightCol.className = 'flex-1 flex justify-end items-center gap-4';
            
            const userIdDiv = document.createElement('div');
            userIdDiv.className = 'text-right';
            userIdDiv.innerHTML = `
                <p class="text-xs text-gray-500">USER:</p>
                <p id="userIdDisplay" class="text-sm font-semibold bg-gray-700 rounded-md px-2 py-0.5 inline-block break-all" style="color: var(--text-subtle); background-color: var(--bg-header);"></p>
            `;
            rightCol.appendChild(userIdDiv);

            const authContainer = document.createElement('div');
            authContainer.id = 'auth-container';
            rightCol.appendChild(authContainer);

            const guideButton = document.createElement('button');
            guideButton.id = 'guide-btn';
            guideButton.className = 'p-1 rounded-full hover:bg-gray-700 transition-colors underline';
            guideButton.textContent = "Guide";
            guideButton.addEventListener('click', () => { helpModal.classList.remove('hidden'); });
            rightCol.appendChild(guideButton);

            headerContainer.appendChild(rightCol);
            
            document.body.prepend(headerContainer);
            updateUIAfterAuthChange();
            updateNavButtonsState();
        }

        function renderCategoryView(categoryKey) {
            if (!appState.authReady) return; 
            appState.currentCollection = categoryKey;
            
            if (categoryKey !== 'equipment') {
                appState.activeEquipmentTab = 'armoring';
            }
            
            appState.currentSubcollection = null;
            mainContentContainer.innerHTML = ''; 
            
            renderAppHeader(categoryKey);

            const config = categoryConfig[categoryKey];
            const contentArea = document.createElement('div');
            contentArea.style.flexGrow = '1';

            if (categoryKey !== 'rules_codex') {
                contentArea.className = 'p-8 md:p-16 pt-8 md:pt-8';
            } else {
                contentArea.style.display = 'flex';
                contentArea.style.flexDirection = 'row';
                contentArea.style.alignItems = 'stretch';
            }
            mainContentContainer.appendChild(contentArea);
            
            if (config.viewType === 'multi-table') {
                renderMultiTableView(categoryKey, config, contentArea);
            } else if (config.viewType === 'button_grid') {
                renderButtonGridView(contentArea);
            } else if (config.viewType === 'wiki') {
                renderWikiView(contentArea);
            }
            else {
                renderTableView(categoryKey, config.label, contentArea);
            }
        }

        function renderButtonGridView(container) {
            container.innerHTML = '<h2 class="text-3xl font-bold truncate uppercase mb-6">Dashboard</h2>';
            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3';
            
            const combinedGroup = document.createElement('div');
            combinedGroup.className = "border border-gray-600 p-3 rounded-lg flex flex-col gap-3";
            
            const rulesTitle = document.createElement('h3');
            rulesTitle.className = 'text-xl font-bold uppercase cursor-pointer hover:underline text-left';
            rulesTitle.textContent = categoryConfig['rules_codex'].label;
            rulesTitle.addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo({ view: 'renderCategoryView', args: ['rules_codex'] });
            });
            combinedGroup.appendChild(rulesTitle);

            grid.appendChild(combinedGroup);


            const categoriesToShow = ['species', 'factions', 'origins', 'occupations', 'disadvantages', 'features', 'skills', 'augmentations', 'invocations', 'equipment', 'societies'];

            categoriesToShow.forEach(parentKey => {
                const parentConfig = categoryConfig[parentKey];
                if (!parentConfig) return;

                const group = document.createElement('div');
                group.className = "border border-gray-600 p-3 rounded-lg flex flex-col";

                const title = document.createElement('h3');
                title.className = 'text-xl font-bold uppercase cursor-pointer hover:underline text-left';
                title.textContent = parentConfig.label;
                title.addEventListener('click', () => {
                    navigateTo({ view: 'renderCategoryView', args: [parentKey] });
                });
                group.appendChild(title);
                
                const subcatContainer = document.createElement('div');
                subcatContainer.className = 'mt-2 pl-4 border-l-2 border-gray-700 space-y-1';
                
                const allSubLinks = new Map();

                if (parentConfig.subcategories) {
                    for (const subcatKey in parentConfig.subcategories) {
                        allSubLinks.set(subcatKey, parentConfig.subcategories[subcatKey].label);
                    }
                }
                const allFields = {...(parentConfig.fields || {})};
                if(parentConfig.tables) {
                        Object.values(parentConfig.tables).forEach(table => {
                            Object.assign(allFields, table.fields);
                        });
                }
                for(const fieldKey in allFields) {
                    const field = allFields[fieldKey];
                    if (field.manageable && field.source && !allSubLinks.has(field.source)) {
                        const subConfig = getActiveConfig(field.source);
                        let label = subConfig ? subConfig.label : field.source.replace(/_/g, " ");
                        allSubLinks.set(field.source, label);
                    }
                }

                if (parentKey === 'societies') {
                    allSubLinks.delete('society_society');
                    allSubLinks.delete('prerequisite');
                    allSubLinks.delete('modifier');
                }
                if (parentKey === 'equipment') {
                    allSubLinks.delete('resistance_type');
                    allSubLinks.delete('skills');
                    allSubLinks.delete('critical_effect');
                    allSubLinks.delete('special');
                }
                
                allSubLinks.delete('critical_success_effect');
                allSubLinks.delete('critical_failure_effect');

                let sortedKeys = Array.from(allSubLinks.keys());
                
                if (parentKey === 'species') {
                    const order = ['modifier', 'species_movement', 'species_size', 'species_type'];
                    sortedKeys = order.filter(key => allSubLinks.has(key));
                    const remaining = Array.from(allSubLinks.keys()).filter(k => !order.includes(k)).sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b)));
                    sortedKeys.push(...remaining);
                } else if (parentKey === 'equipment') {
                    const equipmentOrder = ['armoring', 'gear', 'mecha', 'weaponry'];
                    equipmentOrder.forEach(key => {
                        const tableConfig = parentConfig.tables[key];
                        if (tableConfig) {
                            subcatContainer.appendChild(createDashboardLink(key, tableConfig.label, parentKey, true));
                        }
                    });
                    const remainingKeys = Array.from(allSubLinks.keys()).filter(key => !equipmentOrder.includes(key) && key !== 'armor_class' && key !== 'skills');
                        if (subcatContainer.hasChildNodes() && remainingKeys.length > 0){
                            const hr = document.createElement('hr');
                            hr.className = 'border-gray-600 my-1';
                            subcatContainer.appendChild(hr);
                        }
                        remainingKeys.sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b))).forEach(key => {
                            subcatContainer.appendChild(createDashboardLink(key, allSubLinks.get(key), parentKey, false));
                        });
                        sortedKeys = []; 
                } else {
                    sortedKeys.sort((a,b) => allSubLinks.get(a).localeCompare(allSubLinks.get(b)));
                }

                sortedKeys.forEach(key => {
                    subcatContainer.appendChild(createDashboardLink(key, allSubLinks.get(key), parentKey));
                });

                if(subcatContainer.hasChildNodes()){
                        group.appendChild(subcatContainer);
                }
                
                grid.appendChild(group);
            });

            container.appendChild(grid);
        }

        function createDashboardLink(key, label, parentKey, isBold = false) {
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = label.toUpperCase();
            link.className = `block text-sm hover:underline hover:text-white ${isBold ? 'text-gray-300 font-semibold' : 'text-gray-400'}`;
            link.addEventListener('click', (e) => {
                e.preventDefault(); e.stopPropagation();
                if (parentKey === 'equipment' && categoryConfig[parentKey].tables[key]) {
                    navigateTo({ view: 'renderCategoryView', args: [parentKey] });
                    setTimeout(()=> {
                        document.querySelector(`button[data-tab-key='${key}']`)?.click();
                    }, 50);
                } else {
                    navigateTo({ view: 'renderManagementView', args: [key, parentKey] });
                }
            });
            return link;
        }

        function renderTableView(collectionKey, title, container, parentCategoryKey = null) {
            appState.currentCollection = parentCategoryKey || collectionKey;
            appState.currentSubcollection = parentCategoryKey ? collectionKey : null;

            const config = getActiveConfig(collectionKey);
            if (!config) {
                showError(`Configuration for "${collectionKey}" not found.`);
                return;
            }

            container.innerHTML = `
                <div class="flex flex-col sm:flex-row justify-between sm:items-center my-4 gap-4">
                    <div class="flex-grow min-w-0">
                        <h2 id="table-title-${collectionKey}" class="text-3xl font-bold truncate uppercase">${title}</h2>
                    </div>
                    <div class="flex items-center gap-2">
                        <input type="text" id="search-input" placeholder="Search by name..." class="global-form-input !w-auto" value="${appState.searchTerm}">
                        <button id="add-new-btn" class="btn btn-primary auth-required">ADD NEW</button>
                    </div>
                </div>
                <div class="shadow-lg rounded-lg overflow-x-auto">
                    <table class="data-table min-w-full">
                        <thead id="table-header-${collectionKey}"></thead>
                        <tbody id="table-body-${collectionKey}"></tbody>
                    </table>
                </div>
            `;
            
            const titleElement = container.querySelector(`#table-title-${collectionKey}`);
            if (titleElement) {
                const keyForListener = collectionKey;
                const parentKeyForListener = parentCategoryKey;
                titleElement.addEventListener('click', () => {
                    if (!appState.isAnonymous) {
                        appState.currentCollection = parentKeyForListener || keyForListener;
                        appState.currentSubcollection = parentKeyForListener ? keyForListener : null;
                        openModal(null, {}, true);
                    }
                });
            }

            const addNewBtn = container.querySelector('#add-new-btn');
            if (addNewBtn) {
                const keyForListener = collectionKey;
                const parentKeyForListener = parentCategoryKey;
                addNewBtn.addEventListener('click', () => {
                    appState.currentCollection = parentKeyForListener || keyForListener;
                    appState.currentSubcollection = parentKeyForListener ? keyForListener : null;
                    openModal(null, {}, true);
                });
            }

            const searchInput = container.querySelector('#search-input');
            if (searchInput) {
                let debounceTimer;
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        appState.searchTerm = e.target.value;
                        listenForData(collectionKey);
                    }, 300);
                });
            }
            
            listenForData(collectionKey);
            updateUIAfterAuthChange();
        }

        function renderManagementView(collectionKey, parentCollectionKey) {
            if (!appState.authReady) return;

            const mainCollectionForHeader = parentCollectionKey || collectionKey;
            mainContentContainer.innerHTML = '';
            renderAppHeader(mainCollectionForHeader);

            const config = getActiveConfig(collectionKey);
            if (!config) {
                showError(`Configuration for "${collectionKey}" not found.`);
                return;
            }

            const container = document.createElement('div');
            container.className = 'p-8 md:p-16 pt-8 md:pt-8';
            mainContentContainer.appendChild(container);

            renderTableView(collectionKey, config.label, container, parentCollectionKey);
        }

        function renderMultiTableView(parentCategoryKey, config, container) {
            container.innerHTML = '';
            const tables = config.tables;
            for (const tableKey in tables) {
                const tableConfig = tables[tableKey];
                const tableContainer = document.createElement('div');
                tableContainer.className = 'mb-12';
                container.appendChild(tableContainer);
                renderTableView(tableKey, tableConfig.label, tableContainer, parentCategoryKey);
            }
        }
        
        function renderWikiView(container) {
            container.innerHTML = `
                <div class="wiki-sidebar" id="wiki-sidebar">
                    <h3>Rules Codex</h3>
                    <div id="wiki-sidebar-controls" class="mb-4"></div>
                    <ul id="wiki-directory-list"></ul>
                </div>
                <div class="wiki-content-area-wrapper">
                    <div class="flex justify-end gap-2 mb-4">
                        <button id="wiki-edit-btn" class="btn btn-secondary auth-required" style="display:none;">Edit</button>
                        <button id="wiki-delete-btn" class="btn btn-danger auth-required" style="display:none;">Delete</button>
                    </div>
                    <div class="wiki-content" id="wiki-content">
                        <h2 id="wiki-entry-title">Select an Entry</h2>
                        <div id="wiki-entry-body">
                            <p class="text-gray-400">Please select an entry from the left sidebar or create a new one.</p>
                        </div>
                    </div>
                </div>
            `;

            const sidebarControls = document.getElementById('wiki-sidebar-controls');

            if (appState.isAnonymous) {
                sidebarControls.innerHTML = `
                    <p class="text-xs text-center text-gray-500 p-2 border border-dashed border-gray-600 rounded-md">
                        Please <a href="#" id="wiki-login-link" class="underline font-bold">log in</a> to add or edit entries.
                    </p>
                `;
                document.getElementById('wiki-login-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    handleLogin();
                });
            } else {
                sidebarControls.innerHTML = `
                    <button id="add-wiki-entry-btn" class="btn btn-primary w-full">Add New Entry</button>
                `;
                document.getElementById('add-wiki-entry-btn').addEventListener('click', () => {
                    appState.currentCollection = 'rules_codex';
                    appState.currentSubcollection = null;
                    openModal(null, {}, true);
                });
            }

            document.getElementById('wiki-edit-btn').addEventListener('click', () => {
                if (appState.currentWikiEntryId) {
                    const entry = appState.wikiEntries.find(e => e.id === appState.currentWikiEntryId);
                    if (entry) {
                        appState.currentCollection = 'rules_codex';
                        openModal(entry.id, entry, true);
                    }
                }
            });

            document.getElementById('wiki-delete-btn').addEventListener('click', () => {
                if (appState.currentWikiEntryId) {
                    deleteEntry(appState.currentWikiEntryId);
                }
            });
            
            listenForWikiEntries();
            updateUIAfterAuthChange();
        }

        async function renderWikiDirectory(container, entries, parent = null, level = 0) {
            if (!container) return;
            const ul = document.createElement('ul');
            ul.className = `space-y-1 ${level > 0 ? 'wiki-tree-children' : ''}`;

            const children = entries.filter(entry => (entry.parent || null) === parent).sort((a, b) => (a.order || 0) - (b.order || 0) || a.name.localeCompare(b.name));

            for (const entry of children) {
                const li = document.createElement('li');
                const hasChildren = entries.some(e => e.parent === entry.name);

                const itemContent = document.createElement('div');
                itemContent.className = 'wiki-tree-item';

                let toggleBtnHtml = `<span class="toggle-btn"></span>`;
                if (hasChildren) {
                    toggleBtnHtml = `<button class="toggle-btn" data-toggle-id="${entry.id}">&#9658;</button>`;
                }

                itemContent.innerHTML = `
                    ${toggleBtnHtml}
                    <a href="#" class="wiki-tree-item-content" data-entry-id="${entry.id}">${entry.name}</a>
                `;
                li.appendChild(itemContent);

                if (hasChildren) {
                    const childrenContainer = document.createElement('div');
                    childrenContainer.id = `children-${entry.id}`;
                    childrenContainer.style.display = 'none';
                    await renderWikiDirectory(childrenContainer, entries, entry.name, level + 1);
                    li.appendChild(childrenContainer);

                    const toggleButton = itemContent.querySelector('.toggle-btn');
                    toggleButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = childrenContainer.style.display === 'none';
                        childrenContainer.style.display = isHidden ? 'block' : 'none';
                        toggleButton.innerHTML = isHidden ? '&#9660;' : '&#9658;';
                    });
                }

                const link = itemContent.querySelector('a');
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    displayWikiEntry(entry.id);
                });

                ul.appendChild(li);
            }
            container.innerHTML = '';
            container.appendChild(ul);
        }

        async function displayWikiEntry(docId) {
            const wikiTitle = document.getElementById('wiki-entry-title');
            const wikiBody = document.getElementById('wiki-entry-body');
            const wikiEditBtn = document.getElementById('wiki-edit-btn');
            const wikiDeleteBtn = document.getElementById('wiki-delete-btn');

            wikiTitle.textContent = 'Loading...';
            wikiBody.innerHTML = '<p class="text-center text-gray-400">Loading entry...</p>';
            if(wikiEditBtn) wikiEditBtn.style.display = 'none';
            if(wikiDeleteBtn) wikiDeleteBtn.style.display = 'none';
            appState.currentWikiEntryId = null;

            try {
                const entry = appState.wikiEntries.find(e => e.id === docId);

                if (entry) {
                    wikiTitle.textContent = entry.name.toUpperCase();
                    let contentHtml = '';

                    if (entry.description) contentHtml += `<p>${parseWikiLinks(entry.description)}</p>`;
                    if (entry.mechanic) contentHtml += `<h3>Mechanics</h3><p>${parseWikiLinks(entry.mechanic)}</p>`;
                    if (entry.guide) contentHtml += `<h3>Guide</h3><p>${parseWikiLinks(entry.guide)}</p>`;
                    if (entry.note) contentHtml += `<h3>Notes</h3><p>${parseWikiLinks(entry.note)}</p>`;
                    if (!contentHtml) contentHtml = '<p class="text-gray-400">No content available for this entry.</p>';
                    
                    wikiBody.innerHTML = contentHtml;
                    appState.currentWikiEntryId = docId;

                    if (!appState.isAnonymous) {
                        if(wikiEditBtn) wikiEditBtn.style.display = 'inline-block';
                        if(wikiDeleteBtn) wikiDeleteBtn.style.display = 'inline-block';
                    }

                } else {
                    wikiTitle.textContent = 'Entry Not Found';
                    wikiBody.innerHTML = '<p class="text-red-400">The requested wiki entry could not be found.</p>';
                }
            } catch (error) {
                console.error("Error displaying wiki entry:", error);
                showError("Failed to display wiki entry.");
                wikiTitle.textContent = 'Error';
                wikiBody.innerHTML = '<p class="text-red-400">An error occurred while loading the entry.</p>';
            }
        }
        
        async function getCollectionOptions(collectionName) {
            if (!appState.authReady) return [];
            if (collectionName === 'all_equipment') {
                const equipmentTypes = ['armoring', 'weaponry', 'mecha', 'gear'];
                let allOptions = [];
                for (const type of equipmentTypes) {
                    const options = await getCollectionOptions(type);
                    allOptions.push({ label: type.toUpperCase(), options });
                }
                return allOptions;
            }
            if (collectionName === 'skills_meta') {
                const allSkills = await getCollectionOptions('skills');
                const metaSkills = allSkills.filter(skill => skill.type === 'meta');
                return [{ name: 'Special Ability'}, ...metaSkills];
            }
            if (collectionName === 'rules_codex') {
                const filteredEntries = appState.wikiEntries.filter(entry => entry.id !== appState.editingDocId);
                return filteredEntries.map(entry => ({ name: entry.name, id: entry.id }));
            }


            const collectionPath = `artifacts/${appId}/public/data/${collectionName}`;
            try {
                const querySnapshot = await getDocs(collection(db, collectionPath));
                return querySnapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a,b) => (a.name || '').localeCompare(b.name || ''));
            } catch (error) {
                console.error(`Error getting options from ${collectionName}:`, error);
                showError(`Could not load options for ${collectionName}.`);
                return [];
            }
        }
        
        function getActiveConfig(collectionKey) {
            if (!collectionKey) return null;
            
            if (categoryConfig[collectionKey]) {
                return categoryConfig[collectionKey];
            }
            
            for (const mainKey in categoryConfig) {
                const mainConfig = categoryConfig[mainKey];
                if (mainConfig?.tables && mainConfig.tables[collectionKey]) {
                    return mainConfig.tables[collectionKey];
                }
                if (mainConfig?.subcategories?.[collectionKey]) {
                    return mainConfig.subcategories[collectionKey];
                }
            }
            return null;
        }

        let rulesCodexMap = new Map();

        async function populateRulesCodexMap() {
            if (!appState.authReady) return;
            const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
            try {
                const querySnapshot = await getDocs(collection(db, collectionPath));
                rulesCodexMap.clear();
                appState.wikiEntries = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                appState.wikiEntries.forEach(entry => {
                    rulesCodexMap.set(entry.name, entry.id);
                });
            } catch (error) {
                console.error("Error populating Rules Codex Map:", error);
                // This error will be caught by the caller in the onAuthStateChanged handler
                throw error;
            }
        }

        function listenForWikiEntries() {
            if (!appState.userId) return; 

            if (appState.activeListenerUnsubscribe) {
                appState.activeListenerUnsubscribe();
            }

            const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
            const q = query(collection(db, collectionPath));
            const wikiSidebar = document.getElementById('wiki-directory-list');
            if(wikiSidebar) wikiSidebar.innerHTML = '<li>Loading entries...</li>';

            appState.activeListenerUnsubscribe = onSnapshot(q, (snapshot) => {
                appState.wikiEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                rulesCodexMap.clear();
                appState.wikiEntries.forEach(entry => rulesCodexMap.set(entry.name, entry.id));

                if (wikiSidebar) {
                    if (snapshot.empty) {
                        wikiSidebar.innerHTML = '<li>No entries found.</li>';
                    } else {
                        renderWikiDirectory(wikiSidebar, appState.wikiEntries, null);
                        if (appState.currentWikiEntryId && appState.wikiEntries.some(e => e.id === appState.currentWikiEntryId)) {
                            displayWikiEntry(appState.currentWikiEntryId);
                        } else if (appState.wikiEntries.length > 0) {
                           // displayWikiEntry(appState.wikiEntries[0].id);
                        }
                    }
                }
            }, error => {
                console.error("Error listening for wiki entries:", error);
                if(wikiSidebar) wikiSidebar.innerHTML = '<li class="text-red-500">Error loading entries.</li>';
                showError("Failed to load wiki entries. Check console for details.");
            });
        }


        function createTableRow(docId, data, collectionKey) {
            const config = getActiveConfig(collectionKey);
            
            if (!config || !config.fields) {
                console.error("Could not find config for table row", collectionKey);
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="99" class="text-red-500">Config error for ${collectionKey}</td>`;
                return tr;
            }
            const fields = config.fields;
            const columnsToShow = config.directory_columns || Object.keys(fields);

            const tr = document.createElement('tr');
            tr.className = 'cursor-pointer';
            tr.dataset.id = docId;
            tr.addEventListener('click', () => {
                const parentConfigKey = Object.keys(categoryConfig).find(key => 
                    (categoryConfig[key].tables && categoryConfig[key].tables[collectionKey]) ||
                    (categoryConfig[key].subcategories && categoryConfig[key].subcategories[collectionKey])
                );

                if (parentConfigKey) {
                    appState.currentCollection = parentConfigKey;
                    appState.currentSubcollection = collectionKey;
                } else {
                    appState.currentCollection = collectionKey;
                    appState.currentSubcollection = null;
                }

                const canEdit = !appState.isAnonymous;
                openModal(docId, data, canEdit);
            });

            columnsToShow.forEach(fieldKey => {
                const td = document.createElement('td');
                let value = data[fieldKey];
                td.className = 'px-6 py-4 whitespace-nowrap text-sm text-gray-300 uppercase';
                
                if(fieldKey === 'is_specialization' || fieldKey === 'restricted') {
                    value = value === true || value === 'true' ? 'YES' : 'NO';
                } else if (fields[fieldKey]?.type === 'json_list' && typeof value === 'string' && value.startsWith('[')) {
                    try {
                        const parsed = JSON.parse(value);
                        value = parsed.map(p => `${p.name.toUpperCase()}: ${p.value}`).join(', ');
                    } catch (e) { /* Do nothing, display raw string if parse fails */ }
                }
                
                if(Array.isArray(value)) {
                    td.textContent = value.join(', ').toUpperCase();
                } else if (typeof value === 'object' && value !== null) {
                    td.textContent = JSON.stringify(value).toUpperCase();
                } else {
                    td.textContent = (value || '').toString().toUpperCase();
                }

                tr.appendChild(td);
            });
            return tr;
        }
        
        function listenForData(collectionName) {
            if (!appState.userId) return;

            if (appState.activeListenerUnsubscribe) {
                appState.activeListenerUnsubscribe();
            }

            const collectionPath = `artifacts/${appId}/public/data/${collectionName}`;
            let q = collection(db, collectionPath);

            if (appState.searchTerm) {
                const searchTermLower = appState.searchTerm.toLowerCase();
                q = query(q, where('name', '>=', searchTermLower), where('name', '<=', searchTermLower + '\uf8ff'));
            }
            q = query(q, orderBy(appState.sortBy, appState.sortDirection));

            
            const tableHeader = document.getElementById(`table-header-${collectionName}`);
            const tableBody = document.getElementById(`table-body-${collectionName}`);
            
            if (!tableHeader) return;
            tableHeader.innerHTML = '';
            const config = getActiveConfig(collectionName);
            if (!config || !config.fields) {
                console.error("Could not find config for table header", collectionName);
                return;
            }
            const fields = config.fields;
            const columnsToShow = config.directory_columns || Object.keys(fields);

            const tr = document.createElement('tr');
            columnsToShow.forEach(fieldKey => {
                const th = document.createElement('th');
                th.className = 'px-6 py-3 text-left text-xs font-bold tracking-wider';
                const fieldConfig = fields[fieldKey] || {};
                th.innerHTML = `<span>${(fieldConfig.label || fieldKey.replace(/_/g, ' ')).toUpperCase()}</span>`;
                th.dataset.sortKey = fieldKey;
                th.addEventListener('click', () => {
                    if (appState.sortBy === fieldKey) {
                        appState.sortDirection = appState.sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        appState.sortBy = fieldKey;
                        appState.sortDirection = 'asc';
                    }
                    listenForData(collectionName);
                });
                tr.appendChild(th);
            });
            tableHeader.appendChild(tr);

            appState.activeListenerUnsubscribe = onSnapshot(q, (snapshot) => {
                if (!tableBody) return;
                
                tableBody.innerHTML = '';
                
                if (snapshot.empty) {
                    const colspan = columnsToShow.length;
                    tableBody.innerHTML = `<tr><td colspan="${colspan}" class="px-6 py-4 text-center text-gray-400">NO ENTRIES FOUND.</td></tr>`;
                    return;
                }
                
                snapshot.forEach((doc) => {
                    const docId = doc.id;
                    const data = doc.data();
                    const newRow = createTableRow(docId, data, collectionName);
                    tableBody.appendChild(newRow);
                });

                if (collectionName === 'rules_codex') {
                    populateRulesCodexMap();
                }

            }, error => {
                console.error(`Error listening for data from ${collectionName}:`, error);
                showError(`Failed to load data from ${collectionName}.`);
            });
        }
        
        // --- Form Field Creation Helpers ---

        function createTextField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            return `<input type="text" id="${fieldKey}" name="${fieldKey}" value="${savedValue}" class="global-form-input ${displayClass}" ${readonlyAttr}>`;
        }

        function createNumberField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            return `<input type="number" id="${fieldKey}" name="${fieldKey}" value="${savedValue || 0}" class="global-form-input ${displayClass}" ${readonlyAttr}>`;
        }

        function createTextareaField(fieldKey, savedValue, isEditMode) {
            const readonlyAttr = isEditMode ? '' : 'readonly';
            const displayClass = isEditMode ? '' : 'display-only-input';
            let content = savedValue;
            if (!isEditMode && (fieldKey === 'description' || fieldKey === 'note' || fieldKey === 'mechanic' || fieldKey === 'guide')) { /* Added guide to wiki parsing */
                content = parseWikiLinks(savedValue);
            }
            return `<textarea id="${fieldKey}" name="${fieldKey}" class="global-form-input ${displayClass}" rows="1" ${readonlyAttr}>${content}</textarea>`;
        }

        function createBooleanField(fieldKey, savedValue, isEditMode) {
            const savedBool = savedValue === true || savedValue === 'true';
            if (!isEditMode) {
                return `<div class="global-form-input display-only-input">${savedBool ? 'YES' : 'NO'}</div>`;
            }
            return `<div class="flex gap-4">
                        <label class="flex items-center gap-2">
                            <input type="radio" name="${fieldKey}" value="true" ${savedBool ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                            <span>YES</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="radio" name="${fieldKey}" value="false" ${!savedBool ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                            <span>NO</span>
                        </label>
                    </div>`;
        }

        function createRadioField(fieldKey, fieldConfig, savedValue, isEditMode) {
            const options = fieldConfig.options || [];
            const valueToSelect = (savedValue === '' && fieldKey === 'modifier_type') ? 'constant' : savedValue;
            if (!isEditMode) {
                return `<div class="global-form-input display-only-input">${(valueToSelect || '').toUpperCase()}</div>`;
            }
            const radioHtml = options.map(opt => `
                <label class="flex items-center gap-2">
                    <input type="radio" name="${fieldKey}" value="${opt}" ${valueToSelect === opt ? 'checked' : ''} class="h-4 w-4 rounded-full border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                    <span>${opt.toUpperCase()}</span>
                </label>
            `).join('');
            return `<div class="flex gap-4">${radioHtml}</div>`;
        }

        async function createSelectField(fieldKey, fieldConfig, savedValue, isEditMode) {
            let options = [];
            if (fieldConfig.source === 'skills_meta') {
                const allSkills = await getCollectionOptions('skills');
                const metaSkills = allSkills.filter(skill => skill.type === 'meta');
                options = [{ name: 'Special Ability'}, ...metaSkills];
            } else if (fieldConfig.source) {
                options = await getCollectionOptions(fieldConfig.source);
            } else if (fieldConfig.options) {
                options = fieldConfig.options.map(opt => ({ name: opt, dc: 0}));
            }
            
            if (!isEditMode) {
                const displayValue = options.find(opt => opt.name === savedValue)?.name || savedValue || '';
                return `<div class="global-form-input display-only-input">${String(displayValue).toUpperCase()}</div>`;
            }

            let optionHtml = options.map(opt => `<option value="${opt.name}" ${savedValue == opt.name ? 'selected' : ''} data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}">${String(opt.name).toUpperCase()}</option>`).join('');
            return `<select id="${fieldKey}" name="${fieldKey}" class="global-form-input form-select-arrow"><option value="">--CHOOSE--</option>${optionHtml}</select>`;
        }


        async function createMultiselectField(fieldKey, fieldConfig, savedValue, isEditMode) {
            const savedArray = Array.isArray(savedValue) ? savedValue : [];

            if (!isEditMode) {
                const displayValue = savedArray.length > 0 ? savedArray.join(', ').toUpperCase() : 'NONE';
                return `<div class="global-form-input display-only-input">${displayValue}</div>`;
            }

            if (fieldConfig.source === 'all_equipment') {
                const equipmentGroups = await getCollectionOptions(fieldConfig.source);
                let groupedCheckboxHtml = '';
                
                equipmentGroups.forEach(group => {
                    if(group.options.length > 0) {
                        groupedCheckboxHtml += `<h5 class="font-bold text-sm uppercase text-gray-400 mt-2 first:mt-0">${group.label}</h5>`;
                        groupedCheckboxHtml += group.options.map(opt => `
                            <label class="flex items-center space-x-2 p-1 rounded-md pl-2">
                                <input type="checkbox" name="${fieldKey}" value="${opt.name}" ${savedArray.includes(opt.name) ? 'checked' : ''} class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500" data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}">
                                <span class="uppercase">${opt.name}</span>
                            </label>`).join('');
                    }
                });

                return `<div class="multiselect-container">${groupedCheckboxHtml || `<span class="text-gray-500">No equipment available.</span>`}</div>`;
            }

            let options = await getCollectionOptions(fieldConfig.source);
            if (fieldKey === 'prerequisite' && appState.editingDocId) {
                options = options.filter(opt => opt.id !== appState.editingDocId);
            }

            if (options.length === 0) {
                return `<div class="multiselect-container"><span class="text-gray-500">No options available.</span></div>`;
            } else {
                const checkboxHtml = options.map(opt => `
                    <label class="flex items-center space-x-2 p-1 rounded-md">
                        <input type="checkbox" name="${fieldKey}" value="${opt.name}" data-dc="${opt.dc || 0}" data-cp="${opt.cp || 0}" ${savedArray.includes(opt.name) ? 'checked' : ''} class="h-4 w-4 rounded border-gray-600 bg-gray-700 text-gray-400 focus:ring-gray-500">
                        <span class="uppercase">${opt.name}</span>
                    </label>`).join('');
                return `<div class="multiselect-container">${checkboxHtml}</div>`;
            }
        }

        function createJsonListField(fieldKey, savedValue, isEditMode) {
            if (!isEditMode) {
                let displayValue = savedValue;
                try {
                    const parsed = JSON.parse(savedValue);
                    if (Array.isArray(parsed)) {
                        displayValue = parsed.map(p => `${p.name.toUpperCase()}: ${p.value}`).join(', ');
                    }
                } catch (e) { /* display raw string */ }
                return `<div class="global-form-input display-only-input">${displayValue}</div>`;
            }
            return `<div id="json-list-editor-${fieldKey}" class="p-2 border border-gray-600 rounded-md"></div>
                                        <textarea id="${fieldKey}" name="${fieldKey}" class="hidden">${savedValue}</textarea>`;
        }

        function createReadonlyTextField(fieldKey, savedValue) {
            return `<input type="text" id="${fieldKey}" name="${fieldKey}" value="${savedValue || 0}" class="global-form-input cursor-not-allowed display-only-input" readonly>`;
        }

        async function createFormFieldHtml(fieldKey, fieldConfig, savedValue, collectionKey, isEditMode) {
            const labelText = (fieldConfig.label || fieldKey.replace(/_/g, ' ')).toUpperCase();
            let labelHtml = `<label for="${fieldKey}" class="global-form-label">${labelText}</label>`;

            let buttonHtml = '';
            if (fieldConfig.manageable) {
                buttonHtml = `<button type="button" data-manage-source="${fieldConfig.source}" class="flex items-center gap-2 text-sm font-medium mb-1 underline hover:text-white w-full justify-start global-form-label" ${isEditMode ? '' : 'disabled'}>
                                <span>${labelText}</span>
                              </button>`;
                labelHtml = '';
            } else if (fieldConfig.aiEnabled) {
                labelHtml = `<div class="flex justify-between items-center">
                                <label for="${fieldKey}" class="global-form-label">${labelText}</label>
                                <button type="button" id="generate-description-btn" class="flex items-center gap-1.5 text-xs text-gray-400 hover:text-white transition-colors underline auth-required" ${isEditMode ? '' : 'style="display:none;"'}>
                                    GENERATE
                                </button>
                             </div>`;
            }

            let fieldHtml = '';
            switch (fieldConfig.type) {
                case 'boolean': fieldHtml = createBooleanField(fieldKey, savedValue, isEditMode); break;
                case 'radio': fieldHtml = createRadioField(fieldKey, fieldConfig, savedValue, isEditMode); break; 
                case 'select': fieldHtml = await createSelectField(fieldKey, fieldConfig, savedValue, isEditMode); break;
                case 'multiselect': fieldHtml = await createMultiselectField(fieldKey, fieldConfig, savedValue, isEditMode); break;
                case 'json_list': fieldHtml = createJsonListField(fieldKey, savedValue, isEditMode); break;
                case 'textarea': fieldHtml = createTextareaField(fieldKey, savedValue, isEditMode); break;
                case 'readonlytext': fieldHtml = createReadonlyTextField(fieldKey, savedValue); break;
                case 'number': fieldHtml = createNumberField(fieldKey, savedValue, isEditMode); break;
                default: fieldHtml = createTextField(fieldKey, savedValue, isEditMode);
            }
            return `<div>${buttonHtml || labelHtml}${fieldHtml}</div>`;
        }
        
        function getSingularLabel(label) {
            if (!label) return '';
            if (label.toUpperCase().endsWith('IES')) {
                return label.slice(0, -3) + 'Y';
            }
            if (label.toUpperCase().endsWith('S')) {
                return label.slice(0, -1);
            }
            return label;
        }

        async function openModal(docId = null, data = {}, isEditMode = true) {
            appState.editingDocId = docId;
            const collectionKey = appState.currentSubcollection || appState.currentCollection;
            
            const config = getActiveConfig(collectionKey);
            
            const modalLabel = getSingularLabel(config.label).toUpperCase();
            const modalHeader = modalTitle.parentElement;

            // Clear previous back button and set title
            const existingBackBtn = modalHeader.querySelector('#modal-back-btn');
            if (existingBackBtn) existingBackBtn.remove();
            modalTitle.textContent = `${isEditMode ? 'MANAGE' : 'VIEW'} ${modalLabel}`;
            
            // Add Back button if there's a navigation context
            if (appState.navigationContext) {
                const backButton = document.createElement('button');
                backButton.id = 'modal-back-btn';
                backButton.className = 'btn btn-secondary !py-1 !px-2 mr-4';
                backButton.textContent = 'BACK';
                backButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    const goBackInModal = () => {
                        const { parentCollection, parentSubcollection, docId, data } = appState.navigationContext;
                        appState.currentCollection = parentCollection;
                        appState.currentSubcollection = parentSubcollection;
                        appState.navigationContext = null; 
                        openModal(docId, data, true);
                    };

                    if (isFormDirty()) {
                        appState.pendingNavigation = goBackInModal;
                        unsavedChangesModal.classList.remove('hidden');
                    } else {
                        goBackInModal();
                    }
                });
                modalHeader.prepend(backButton);
            }

            formFieldsContainer.innerHTML = '<div class="text-center">LOADING...</div>';
            entryModal.classList.remove('hidden');
            
            const availableFields = Object.keys(config.fields);
            
            const sortedFieldKeys = availableFields.sort((a, b) => {
                const indexA = masterFieldOrder.indexOf(a);
                const indexB = masterFieldOrder.indexOf(b);
                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                return a.localeCompare(b);
            });
            
            const formHtml = await Promise.all(sortedFieldKeys.map(async (fieldKey) => {
                const fieldConfig = config.fields[fieldKey];
                const savedValue = data[fieldKey] === undefined ? (fieldConfig.type === 'multiselect' ? [] : (fieldConfig.type === 'json_list' ? '[]' : (fieldConfig.type === 'number' ? 0 : ''))) : data[fieldKey];
                return createFormFieldHtml(fieldKey, fieldConfig, savedValue, collectionKey, isEditMode);
            }));

            formFieldsContainer.innerHTML = formHtml.join('');
            
            const modalDataBtn = document.getElementById('modal-data-btn');
            const modalDataDropdown = document.getElementById('modal-data-dropdown');

            modalDataDropdown.innerHTML = ''; // Clear previous items

            if (!isEditMode && !appState.isAnonymous) {
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => openModal(docId, data, true));
                modalDataDropdown.appendChild(editButton);
            } else if (isEditMode) {
                const saveButton = document.createElement('button');
                saveButton.type = 'submit';
                saveButton.setAttribute('form', 'entry-form');
                saveButton.textContent = 'Save';
                modalDataDropdown.appendChild(saveButton);
            }

            const summaryButton = document.createElement('button');
            summaryButton.id = 'modal-summary-btn';
            summaryButton.textContent = 'Summary';
            summaryButton.addEventListener('click', () => showSummaryModal('modal'));
            modalDataDropdown.appendChild(summaryButton);

            const localMenuContainer = document.createElement('div');
            localMenuContainer.className = 'submenu-container';
            localMenuContainer.innerHTML = `
                <span>Local</span>
                <div class="submenu">
                    <button id="modal-local-save-btn">Save</button>
                    <button id="modal-local-load-btn">Load</button>
                </div>
            `;
            modalDataDropdown.appendChild(localMenuContainer);
            
            const cancelButton = document.createElement('button');
            cancelButton.id = 'modal-cancel-btn';
            cancelButton.textContent = 'Cancel';
            cancelButton.addEventListener('click', () => closeModal());
            modalDataDropdown.appendChild(cancelButton);

            const deleteButton = document.createElement('button');
            deleteButton.id = 'modal-delete-btn';
            deleteButton.className = 'text-red-400 hover:bg-red-800 auth-required';
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => deleteEntry(docId));
            modalDataDropdown.appendChild(deleteButton);


            modalDataBtn.onclick = (e) => {
                e.stopPropagation();
                modalDataDropdown.classList.toggle('show');
            };
            
            document.getElementById('modal-local-save-btn').addEventListener('click', () => saveLocal(entryForm, collectionKey));
            document.getElementById('modal-local-load-btn').addEventListener('click', () => loadLocal(entryForm));
            document.getElementById('entry-form').addEventListener('submit', handleFormSubmit);

            formFieldsContainer.querySelectorAll('button[data-manage-source]').forEach(button => {
                button.addEventListener('click', () => handleManageClick(button.dataset.manageSource));
            });
            const genDescBtn = document.getElementById('generate-description-btn');
            if(genDescBtn) {
                genDescBtn.addEventListener('click', () => generateDescription(collectionKey));
            }
            
            const textareas = formFieldsContainer.querySelectorAll('textarea');
            const autosize = (el) => {
                setTimeout(() => {
                    el.style.height = 'auto';
                    el.style.height = (el.scrollHeight) + 'px';
                }, 0);
            };

            textareas.forEach(textarea => {
                textarea.addEventListener('input', () => autosize(textarea));
                autosize(textarea);
            });

            for (const fieldKey of Object.keys(config.fields)) {
                const fieldConfig = config.fields[fieldKey];
                if (fieldConfig.type === 'json_list' && isEditMode) {
                    await setupJsonListEditor(fieldKey, fieldConfig);
                }
            }
            
            if (collectionKey === 'modifier' || collectionKey === 'prerequisite') {
                const aspectSelect = formFieldsContainer.querySelector('#aspect');
                const aspectSubtypeContainer = formFieldsContainer.querySelector('#aspect_subtype')?.parentElement;

                const updateSubtypeOptions = async () => {
                    const selectedAspect = aspectSelect.value;
                    const subtypeSelect = formFieldsContainer.querySelector('#aspect_subtype');
                    if (!subtypeSelect || !aspectSubtypeContainer) return;
                    
                    const currentSubtypeValue = data.aspect_subtype || '';
                    subtypeSelect.innerHTML = '<option value="">--CHOOSE--</option>'; 
                    aspectSubtypeContainer.style.display = 'none';

                    let options = [];
                    
                    const attributeOptions = ['Strength', 'Agility', 'Constitution', 'Intellect', 'Wisdom', 'Charisma', 'Might', 'Reflex', 'Fortitude', 'Logic', 'Will', 'Etiquette'];
                    const skillOptions = async () => {
                        const individualSkills = await getCollectionOptions('skills');
                        return individualSkills.map(s => s.name);
                    };
                    const combatOptions = [
                        'health', 'vitality', 'initiative', 
                        'melee attack', 'ranged attack', 'unarmed attack',
                        'ballistic weapon attack', 'heavy weapon attack', 'energy weapon attack', 'heavy energy weapon attack',
                        'damage', 'melee damage', 'ranged damage', 'critical score', 
                        'dodge', 'parry', 'block', 'charge', 'disarm', 'grapple', 'overrun', 'sunder', 'trip', 'drag', 'aim', 'flanking', 
                        'Head DR', 'Torso DR', 'Right Arm DR', 'Left Arm DR', 'Right Leg DR', 'Left Leg DR'
                    ];
                    const otherOptions = ['karma', 'plot points', 'tech level', 'meta level', 'size', 'durability', 'carry capacity', 'component slot', 'ammunition capacity', 'wealth', 'Walk Speed', 'Swim Speed', 'Climb Speed', 'Fly Speed', 'Perception', 'Meta Perception', 'Social Perception', 'Technology Perception', 'aid'];

                    if (selectedAspect.includes('attribute')) {
                        options = attributeOptions;
                    } else if (selectedAspect.includes('skill')) {
                        options = await skillOptions();
                    } else if (selectedAspect.includes('combat')) {
                        options = combatOptions;
                    } else if (selectedAspect.includes('meta')) {
                        const disciplineOptions = await getCollectionOptions('discipline');
                        const invocationOptions = await getCollectionOptions('invocations');
                        options = [
                            ...disciplineOptions.map(d => d.name),
                            ...invocationOptions.map(i => i.name)
                        ];
                    } else if (selectedAspect.includes('other')) {
                        options = otherOptions;
                    }


                    if (options.length > 0) {
                        options.forEach(opt => {
                            subtypeSelect.innerHTML += `<option value="${opt}" ${currentSubtypeValue === opt ? 'selected' : ''}>${opt.toUpperCase()}</option>`;
                        });
                        aspectSubtypeContainer.style.display = '';
                    }
                    subtypeSelect.value = currentSubtypeValue;
                };

                if(aspectSelect && isEditMode){
                    aspectSelect.addEventListener('change', updateSubtypeOptions);
                    await updateSubtypeOptions();
                }
            }

            if (collectionKey === 'area') {
                const shapeSelect = formFieldsContainer.querySelector('#shape');
                const dimensionsFieldContainer = formFieldsContainer.querySelector('#dimensions')?.parentElement;

                const updateDimensionsField = () => {
                    if (!shapeSelect || !dimensionsFieldContainer) return;

                    const selectedShape = shapeSelect.value;
                    const savedValue = data.dimensions || '';
                    
                    const label = dimensionsFieldContainer.querySelector('label');
                    dimensionsFieldContainer.innerHTML = '';
                    if (label) dimensionsFieldContainer.appendChild(label);

                    const dimensionOptions = {
                        burst: ['5-foot radius', '15-foot radius', '30-foot radius', '60-foot radius'],
                        cone: ['15-foot length', '30-foot length', '45-foot length'],
                        line: ['30-foot length', '60-foot length', '90-foot length']
                    };

                    if (dimensionOptions[selectedShape]) {
                        const select = document.createElement('select');
                        select.id = 'dimensions';
                        select.name = 'dimensions';
                        select.className = 'global-form-input form-select-arrow';
                        let optionsHtml = '<option value="">--CHOOSE--</option>';
                        optionsHtml += dimensionOptions[selectedShape].map(opt => `<option value="${opt}" ${savedValue === opt ? 'selected' : ''}>${opt.toUpperCase()}</option>`).join('');
                        select.innerHTML = optionsHtml;
                        if (!isEditMode) {
                            select.disabled = true;
                            select.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(select);
                    } else if (selectedShape === 'cubes') {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.id = 'dimensions';
                        input.name = 'dimensions';
                        input.value = '10ft x 10ft x 10ft cube per invocation level';
                        input.className = 'global-form-input cursor-not-allowed bg-gray-600';
                        input.readOnly = true;
                        if (!isEditMode) {
                            input.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(input);
                    } else {
                        const select = document.createElement('select');
                        select.id = 'dimensions';
                        select.name = 'dimensions';
                        select.className = 'global-form-input form-select-arrow';
                        select.disabled = true;
                        select.innerHTML = '<option value="">--SELECT SHAPE FIRST--</option>';
                        if (!isEditMode) {
                            select.classList.add('display-only-input');
                        }
                        dimensionsFieldContainer.appendChild(select);
                    }
                };

                if (shapeSelect && dimensionsFieldContainer) {
                    if (isEditMode) {
                        shapeSelect.addEventListener('change', updateDimensionsField);
                    } else {
                        shapeSelect.disabled = true;
                        shapeSelect.classList.add('display-only-input');
                    }
                    updateDimensionsField();
                }
            }
            
            setupDynamicCalculations(formFieldsContainer);
            appState.initialFormState = getFormState(entryForm);
            updateUIAfterAuthChange();
        }

        function setupDynamicCalculations(formContainer) {
            const designDcInput = formContainer.querySelector('#design_dc');
            if (!designDcInput) return;

            const updateTotals = () => {
                let totalDc = 0;
                
                const checkedBoxes = formContainer.querySelectorAll('input[type=checkbox]:checked');
                checkedBoxes.forEach(box => {
                    totalDc += Number(box.dataset.dc) || 0;
                });

                const selects = formContainer.querySelectorAll('select');
                selects.forEach(select => {
                    if (select.selectedOptions.length > 0) {
                        const selectedOption = select.selectedOptions[0];
                        if (selectedOption && selectedOption.value) { 
                            totalDc += Number(selectedOption.dataset.dc) || 0;
                        }
                    }
                });
                
                designDcInput.value = totalDc;
            };

            const allSelectableInputs = formContainer.querySelectorAll('select, input[type=checkbox]');
            allSelectableInputs.forEach(input => {
                if (!input.readOnly && !input.disabled) { 
                    input.addEventListener('change', updateTotals);
                }
            });

            updateTotals();
        }


        async function setupJsonListEditor(fieldKey, fieldConfig) {
            const editorContainer = document.getElementById(`json-list-editor-${fieldKey}`);
            const textarea = document.getElementById(fieldKey);
            let items = [];
            try {
                const parsed = JSON.parse(textarea.value);
                if (Array.isArray(parsed)) {
                    items = parsed;
                }
            } catch (e) {
                console.error("Could not parse prerequisite JSON:", textarea.value);
                items = [];
            }

            const redrawList = () => {
                editorContainer.innerHTML = '';
                const listContainer = document.createElement('div');
                listContainer.className = 'space-y-2 mb-2';
                items.forEach((item, index) => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'prereq-item';
                    itemEl.innerHTML = `<span>${item.name.toUpperCase()}: ${item.value}</span>`;
                    const removeBtn = document.createElement('button');
                    removeBtn.type = 'button';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.className = 'ml-4 font-bold text-red-500 hover:text-red-300';
                    removeBtn.addEventListener('click', () => {
                        items.splice(index, 1);
                        textarea.value = JSON.stringify(items);
                        redrawList();
                    });
                    itemEl.appendChild(removeBtn);
                    listContainer.appendChild(itemEl);
                });
                editorContainer.appendChild(listContainer);
                
                const addBtn = document.createElement('button');
                addBtn.type = 'button';
                addBtn.textContent = 'ADD REQUIREMENT';
                addBtn.className = 'btn btn-secondary w-full !py-1 !text-xs';
                addBtn.addEventListener('click', () => showAddForm());
                editorContainer.appendChild(addBtn);
            };
            
            const showAddForm = async () => {
                editorContainer.innerHTML = ''; /* Clear to show the form */
                const formContainer = document.createElement('div');
                formContainer.className = 'p-2 space-y-2 rounded-md';
                formContainer.style.backgroundColor = 'var(--bg-main)';
                
                let selectOptions = [];
                if (fieldConfig.source) {
                    let sourceItems = await getCollectionOptions(fieldConfig.source);
                    if (fieldConfig.source === 'feature' && appState.editingDocId) {
                            sourceItems = sourceItems.filter(item => item.id !== appState.editingDocId);
                    }
                    selectOptions = sourceItems.map(item => `<option value="${item.name}">${item.name.toUpperCase()}</option>`);
                } else if (fieldConfig.options) {
                    selectOptions = fieldConfig.options.map(opt => `<option value="${opt}">${opt.toUpperCase()}</option>`);
                }

                const valueInputHtml = (fieldConfig.source === 'feature') ? '' : `<input type="number" id="prereq-value-input" class="global-form-input" placeholder="VALUE" value="1">`;


                formContainer.innerHTML = `
                    <select class="global-form-input form-select-arrow" id="prereq-name-input">${selectOptions.join('')}</select>
                    ${valueInputHtml}
                    <div class="flex justify-end gap-2">
                        <button type="button" id="prereq-cancel-btn" class="btn btn-secondary !text-xs !py-1 !px-2">CANCEL</button>
                        <button type="button" id="prereq-add-btn" class="btn btn-primary !text-xs !py-1 !px-2">ADD</button>
                    </div>
                `;
                
                editorContainer.appendChild(formContainer);

                document.getElementById('prereq-cancel-btn').addEventListener('click', () => redrawList());
                document.getElementById('prereq-add-btn').addEventListener('click', () => {
                    const nameInput = document.getElementById('prereq-name-input');
                    const valueInput = document.getElementById('prereq-value-input');
                    const value = (fieldConfig.source === 'feature') ? 1 : (valueInput ? Number(valueInput.value) : 1);

                    if (nameInput.value) {
                        items.push({ name: nameInput.value, value: value });
                        textarea.value = JSON.stringify(items);
                        redrawList();
                    }
                });
            };

            redrawList();
        }

        function closeModal(force = false) {
            const isModalOpen = !entryModal.classList.contains('hidden');
            if (!force && isModalOpen && isFormDirty()) {
                appState.pendingNavigation = null; /* Clear pending nav if any */
                unsavedChangesModal.classList.remove('hidden');
                return;
            }
            appState.initialFormState = null;
            appState.editingDocId = null;
            if (!force) {
                appState.navigationContext = null;
            }
            if(entryForm) entryForm.reset();
            const modalDataDropdown = document.getElementById('modal-data-dropdown');
            if(modalDataDropdown) modalDataDropdown.innerHTML = '';
            if(entryModal) entryModal.classList.add('hidden');
        }

        async function handleFormSubmit(e) {
            e.preventDefault();
            if (!appState.userId || appState.isAnonymous) {
                showError("You must be logged in to save changes.");
                return false;
            };

            const collectionKey = appState.currentSubcollection || appState.currentCollection;
            
            const config = getActiveConfig(collectionKey);

            const data = getFormDataObject(entryForm);
            
            // --- Data Normalization ---
            if (data.parent === '') {
                data.parent = null;
            }

            // --- Validation ---
            for (const fieldKey in config.fields) {
                const fieldConfig = config.fields[fieldKey];
                const fieldElement = document.getElementById(fieldKey);
                
                if (fieldConfig.required) {
                    if (!data[fieldKey] || (typeof data[fieldKey] === 'string' && data[fieldKey].trim() === "")) {
                        showError(`${fieldConfig.label || fieldKey} is required.`);
                        if (fieldElement) {
                            fieldElement.classList.add('!border-red-500');
                            fieldElement.focus();
                            fieldElement.addEventListener('input', () => {
                                fieldElement.classList.remove('!border-red-500');
                            }, { once: true });
                        }
                        return false;
                    }
                }
            }
            
            if(data.is_specialization) {
                data.is_specialization = data.is_specialization === 'true';
                if (data.is_specialization && !data.base_skill) {
                    showError("Base Skill is required for a specialization.");
                    const baseSkillField = document.getElementById('base_skill');
                    if (baseSkillField) {
                        baseSkillField.classList.add('!border-red-500');
                        baseSkillField.focus();
                        baseSkillField.addEventListener('change', () => {
                            baseSkillField.classList.remove('!border-red-500');
                        }, { once: true });
                    }
                    return false;
                }
            }
            if(data.is_specialization === false) {
                data.base_skill = '';
            }
            if(data.restricted) {
                data.restricted = data.restricted === 'true'
            }

            const collectionPath = `artifacts/${appId}/public/data/${collectionKey}`;
            try {
                if (appState.editingDocId) {
                    await updateDoc(doc(db, collectionPath, appState.editingDocId), data);
                } else {
                    await addDoc(collection(db, collectionPath), data);
                }
                
                const shouldStayOpen = !!appState.pendingNavigation;
                if(!shouldStayOpen) {
                    closeModal(true);
                }
                return true;
            } catch (error) {
                console.error("Error saving data:", error);
                showError("Error saving data. Check console for details.");
                return false;
            }
        }
        
        function deleteEntry(docId) {
            if (!appState.userId || appState.isAnonymous) {
                showError("You must be logged in to delete entries.");
                return;
            };
            showConfirmModal(`ARE YOU SURE YOU WANT TO DELETE THIS ENTRY? THIS ACTION CANNOT BE UNDONE.`, async () => {
                closeModal();
                const collectionKey = appState.currentSubcollection || appState.currentCollection;
                const collectionPath = `artifacts/${appId}/public/data/${collectionKey}`;
                try {
                    await deleteDoc(doc(db, collectionPath, docId));
                    if (collectionKey === 'rules_codex' && appState.currentWikiEntryId === docId) {
                        document.getElementById('wiki-entry-title').textContent = 'Select an Entry';
                        document.getElementById('wiki-entry-body').innerHTML = '<p class="text-gray-400">Please select an entry from the left sidebar or create a new one.</p>';
                        document.getElementById('wiki-edit-btn').style.display = 'none';
                        document.getElementById('wiki-delete-btn').style.display = 'none';
                        appState.currentWikiEntryId = null;
                    }
                } catch (error) {
                    console.error("Error deleting document:", error);
                    showError("Error deleting entry. Check console for details.");
                }
            });
        }

        function showConfirmModal(message, onConfirm) {
            confirmMessage.textContent = message.toUpperCase();
            appState.confirmCallback = onConfirm;
            confirmModal.classList.remove('hidden');
        }
        function hideConfirmModal() { appState.confirmCallback = null; confirmModal.classList.add('hidden'); }
        function hideUnsavedChangesModal() {
            appState.pendingNavigation = null;
            unsavedChangesModal.classList.add('hidden');
        }
        function showError(message) { errorMessage.textContent = message.toUpperCase(); errorModal.classList.remove('hidden'); }
        function hideErrorModal() { errorModal.classList.add('hidden'); }
        
        async function generateDescription(categoryKey) {
            const btn = document.getElementById('generate-description-btn');
            if(!btn) return;

            const originalContent = btn.innerHTML;
            btn.innerHTML = '<div class="loader"></div>';
            btn.disabled = true;

            const data = getFormDataObject();
            let prompt = `Generate a detailed and creative encyclopedia entry for a sci-fi RPG. The category is "${categoryKey}".\n`;
            prompt += `The entry's name is "${data.name}".\n`;

            if(data.trait && data.trait.length > 0) prompt += `It has the following traits: ${data.trait.join(', ')}.\n`;
            if(data.type) prompt += `It belongs to the following type: ${data.type}.\n`;
            if(data.goals) prompt += `Its primary goals are: ${data.goals}.\n`;

            prompt += `\nWrite an engaging description suitable for a game master's guide. Be evocative and inspiring.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "" // No API key needed for gemini-2.0-flash
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    const descriptionTextarea = document.getElementById('description');
                    if(descriptionTextarea) {
                        descriptionTextarea.value = text;
                        const autosize = (el) => {
                            setTimeout(() => {
                                el.style.height = 'auto';
                                el.style.height = (el.scrollHeight) + 'px';
                            }, 0);
                        };
                        autosize(descriptionTextarea);
                    }
                } else {
                    showError("Could not generate description. The model returned an empty response.");
                }
            } catch (error) {
                console.error("Error generating description:", error);
                showError("Failed to generate description. Check the console for details.");
            } finally {
                btn.innerHTML = originalContent;
                btn.disabled = false;
            }
        }
        
        function parseWikiLinks(text) {
            if (!text) return '';
            return text.replace(/\[\[(.*?)\]\]/g, (match, p1) => {
                const entryName = p1.trim();
                const docId = rulesCodexMap.get(entryName);
                if (docId) {
                    return `<a href="#" class="wiki-link" data-linked-id="${docId}" data-linked-name="${entryName}">${entryName}</a>`;
                }
                return entryName;
            });
        }

        entryModal.addEventListener('click', async (event) => {
            if (event.target.classList.contains('wiki-link')) {
                event.preventDefault();
                const linkedDocId = event.target.dataset.linkedId;
                const linkedDocName = event.target.dataset.linkedName;

                if (linkedDocId) {
                    const collectionPath = `artifacts/${appId}/public/data/rules_codex`;
                    try {
                        const docSnap = await getDoc(doc(db, collectionPath, linkedDocId));
                        if (docSnap.exists()) {
                            if (appState.editingDocId !== linkedDocId) {
                                closeModal(true); 
                            }
                            openModal(linkedDocId, docSnap.data(), false); 
                        } else {
                            showError(`Linked entry "${linkedDocName}" not found.`);
                        }
                    } catch (error) {
                        console.error("Error fetching linked document:", error);
                        showError(`Could not load linked entry "${linkedDocName}".`);
                    }
                }
            }
        });


        // --- Event Listeners ---
        confirmOkBtn.addEventListener('click', () => { if (appState.confirmCallback) appState.confirmCallback(); hideConfirmModal(); });
        confirmCancelBtn.addEventListener('click', hideConfirmModal);
        unsavedCancelBtn.addEventListener('click', hideUnsavedChangesModal);
        unsavedDismissBtn.addEventListener('click', () => {
            closeModal(true);
            if(appState.pendingNavigation) {
                navigateTo(appState.pendingNavigation);
                appState.pendingNavigation = null;
                appState.navigationContext = null;
            }
            hideUnsavedChangesModal();
        });
        unsavedSaveBtn.addEventListener('click', async () => {
            const success = await handleFormSubmit(new Event('submit',{bubbles:true, cancelable: true}));

            if(success && appState.pendingNavigation) {
                navigateTo(appState.pendingNavigation);
                appState.pendingNavigation = null;
                appState.navigationContext = null;
            }
            hideUnsavedChangesModal();
        });

        errorOkBtn.addEventListener('click', hideErrorModal);
        helpCloseBtn.addEventListener('click', () => { helpModal.classList.add('hidden'); });
        summaryCloseBtn.addEventListener('click', () => { summaryModal.classList.add('hidden'); });
        
        window.addEventListener('click', (event) => {
            if (event.target == entryModal || event.target == confirmModal || event.target == errorModal || event.target == unsavedChangesModal || event.target == helpModal || event.target == customModal || event.target == summaryModal) {
                if (event.target === entryModal) {
                    appState.navigationContext = null;
                    closeModal();
                }
                if (event.target == customModal) {
                    customModal.classList.add('hidden');
                }
                if (event.target == summaryModal) {
                    summaryModal.classList.add('hidden');
                }
                if (event.target == confirmModal) hideConfirmModal();
                if (event.target == errorModal) hideErrorModal();
                if (event.target == unsavedChangesModal) hideUnsavedChangesModal();
                if (event.target == helpModal) helpModal.classList.add('hidden');
            }
            const menuButton = document.getElementById('category-menu-button');
            const dropdownMenu = document.getElementById('category-dropdown-menu');
            if (menuButton && dropdownMenu && !menuButton.contains(event.target) && !dropdownMenu.contains(event.target)) {
                dropdownMenu.classList.add('hidden');
            }
            
            const folioMenuButton = document.querySelector('.persona-folio-container .file-menu-button');
            const folioDropdownMenu = document.querySelector('.persona-folio-container .file-menu-dropdown');
            if (folioMenuButton && folioDropdownMenu && !folioMenuButton.contains(event.target) && !folioDropdownMenu.contains(event.target)) {
                folioDropdownMenu.classList.remove('show');
            }
            
            const modalDataBtn = document.getElementById('modal-data-btn');
            const modalDataDropdown = document.getElementById('modal-data-dropdown');
            if (modalDataBtn && modalDataDropdown && !modalDataBtn.contains(event.target) && !modalDataDropdown.contains(event.target)) {
                modalDataDropdown.classList.remove('show');
            }
        });

        const helpMarkdown = `
### **Welcome to the Tangent SFF RPG Database Manager!**
This tool is designed to help you create, manage, and browse all the data for your Sci-Fi Fantasy RPG campaign. From species and factions to equipment and esoteric invocations, everything you need to build your universe is right here.

### **Getting Started: Authentication**
* **Anonymous Users:** By default, you are an anonymous user. You can browse all public data in a read-only mode. This is great for players or anyone who just wants to explore the game's content.
* **Logged-in Users:** To add, edit, or delete entries, you must log in. Click the **LOGIN** button in the top-right corner and sign in with a Google account. Once logged in, you'll have full creative control over the database.

### **Navigating the App**
#### **Header Controls**
* **Main Menu (Top-Left):** Click the dropdown menu (it shows the current category, like 'DASHBOARD') to quickly jump to any main data category.
* **Back/Forward Arrows (Top-Center):** Use these arrows to move through your viewing history, just like in a web browser. Your history is saved for your session, so even if you refresh the page, you can go back to where you were.
* **User Info & Login/Logout (Top-Right):** See your current status (Anonymous or your email) and log in or out.
* **Guide Button:** Click this to view the user guide you're reading right now!

#### **Views**
* **Dashboard:** This is the main landing page. It provides a grid of all major categories. Click any category title to go to its main data table, or click a sub-category link to manage related data (e.g., clicking 'TRAITS' under 'ORIGINS').
* **Table View:** Most categories are displayed as a table.
    * Click any column header to sort the data by that column.
    * Use the search bar to filter entries by name.
    * Click any row to open the details modal for that entry.
* **Wiki View (Rules Codex):** The Rules Codex uses a special wiki-style interface.
    * The sidebar on the left shows a hierarchical tree of all rules entries. Click an entry to view its content on the right.
    * Use the toggle arrows (\`\`) to expand or collapse parent entries.
    * If logged in, you can use the \`Add New Entry\` button to create new articles.

### **Managing Data (Logged-in Users Only)**
#### **The Entry Modal**
This is where all the magic happens. You can open it by clicking a table row or by clicking an \`ADD NEW\` button.
* **Viewing Data:** When you first click a row, the modal opens in view-only mode.
* **Editing Data:** To make changes, click the **DATA** button in the top-right of the modal and select \`Edit\`. The fields will become editable.
* **Saving Data:** After making changes, click the **DATA** button and select \`Save\`.
* **Deleting Data:** To permanently remove an entry, click the **DATA** button and select \`Delete\`. You will be asked to confirm this action.
* **Canceling:** To close the modal without saving, click \`Cancel\` from the DATA menu or click the faded backdrop.

#### **Special Features**
* **Managing Sub-Categories:** Inside the modal, some fields have an underlined label (e.g., \`MODIFIER\`). This is a "Manage" button. Clicking it will take you to the data table for that sub-category, allowing you to add or edit options for dropdowns and multi-select fields throughout the app.
* **AI-Powered Descriptions:** For fields like \`Description\`, you'll see a \`GENERATE\` button. Click this to use AI to write a creative and detailed description based on the other data in the form.
* **Wiki-Linking:** In text areas within the \`Rules Codex\`, you can create links to other entries by wrapping the exact entry name in double square brackets, like this: \`[[Entry Name]]\`. This will automatically create a clickable link in the view.

### **Local Data Backup**
Inside the modal's **DATA** menu, you'll find a \`Local\` submenu.
* **Save:** This saves the current form's data as a JSON file to your computer. This is useful for backing up individual entries or creating templates.
* **Load:** This will open a file picker, allowing you to select a previously saved JSON file and load its data into the current form.
`; 
        
        function convertMarkdownToHtml(markdown) {
            const lines = markdown.trim().split('\n');
            let html = '';
            let listStack = []; 

            for (const line of lines) {
                if (line.trim() === '') continue;

                const indentMatch = line.match(/^(\s*)/);
                const indent = indentMatch ? indentMatch[1].length : 0;
                let trimmedLine = line.trim();

                // Close lists if de-denting
                while (listStack.length > 0 && indent < listStack[listStack.length - 1].indent) {
                     html += `</${listStack.pop().type}>`;
                }

                if (trimmedLine.startsWith('### **')) {
                    html += `<h3 class="text-2xl font-bold mt-6 mb-2 text-gray-100">${trimmedLine.substring(5, trimmedLine.length - 2)}</h3>`;
                } else if (trimmedLine.startsWith('#### **')) {
                    html += `<h4 class="text-lg font-semibold mt-4 mb-1 text-gray-200">${trimmedLine.substring(6, trimmedLine.length - 2)}</h4>`;
                } else if (trimmedLine.startsWith('* ')) {
                    if (listStack.length === 0 || listStack[listStack.length - 1].type !== 'ul') {
                        html += `<ul class="list-disc list-inside ml-4 space-y-2">`;
                        listStack.push({ type: 'ul', indent });
                    }
                    let content = trimmedLine.substring(2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    html += `<li>${content}</li>`;
                } else {
                     // Close any open lists if it's a regular paragraph
                    while (listStack.length > 0) {
                        html += `</${listStack.pop().type}>`;
                    }
                    html += `<p class="mt-2">${trimmedLine.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`;
                }
            }
            
            // Close any remaining open lists
            while (listStack.length > 0) {
                html += `</${listStack.pop().type}>`;
            }

            return html.replace(/`([^`]+)`/g, '<code class="bg-gray-700 text-gray-300 rounded px-1 py-0.5">$1</code>');
        }

        helpContent.innerHTML = convertMarkdownToHtml(helpMarkdown);

    </script>
</body>
</html>
